#include <linux/init.h>
#include <linux/module.h>
#include <linux/cdev.h>
#include <linux/poll.h>
#include <linux/of_irq.h>
#include <linux/of_device.h>
#include <linux/spi/spi.h>
#include <linux/gpio.h>
#include <linux/gpio/consumer.h>
#include <linux/delay.h>
#include <linux/interrupt.h>
#include <linux/kfifo.h>
#include <linux/wait.h>
#include <linux/uaccess.h>
#include <linux/of_gpio.h>
#include <linux/jiffies.h>

#include "sx127x.h"
#include "sx127xlib.h"
#include "sx1278Regs-Fsk.h"
#include "sx1278Regs-LoRa.h"


#define DRV_NAME        "lora"
#define DRIVER_VER1        0                    //
#define DRIVER_VER2        1                    //
#define DRV_MAJOR        104                 //
#define DRV_MINOR         2                    //

//debug macro
#undef    DEBUG
//#define DEBUG
#ifdef DEBUG
#define    DPRINTK( x... )        printk(DRV_NAME":" x)
#else
#define DPRINTK( x... )
#endif

/*!
 * Constant values need to compute the RSSI value
 */
#define RSSI_OFFSET_LF                              -164
#define RSSI_OFFSET_HF                              -157


#define XTAL_FREQ                                   32000000
#define FREQ_STEP                                   6103515625
#define RF_MID_BAND_THRESH                          525000000


#define SX127X_REGADDR(reg) (reg & 0x7f)
#define SX127X_WRITEADDR(addr) (addr | (1 << 7))

/*!
 * \brief Radio hardware registers initialization definition
 *
 * \remark Can be automatically generated by the SX1276 GUI (not yet implemented)
 */
#define RADIO_INIT_REGISTERS_VALUE                \
{                                                 \
    { MODEM_FSK , REG_LNA                , 0x23 },\
    { MODEM_FSK , REG_RXCONFIG           , 0x1E },\
    { MODEM_FSK , REG_RSSICONFIG         , 0xD2 },\
    { MODEM_FSK , REG_AFCFEI             , 0x01 },\
    { MODEM_FSK , REG_PREAMBLEDETECT     , 0xAA },\
    { MODEM_FSK , REG_OSC                , 0x07 },\
    { MODEM_FSK , REG_SYNCCONFIG         , 0x12 },\
    { MODEM_FSK , REG_SYNCVALUE1         , 0xC1 },\
    { MODEM_FSK , REG_SYNCVALUE2         , 0x94 },\
    { MODEM_FSK , REG_SYNCVALUE3         , 0xC1 },\
    { MODEM_FSK , REG_PACKETCONFIG1      , 0xD8 },\
    { MODEM_FSK , REG_FIFOTHRESH         , 0x8F },\
    { MODEM_FSK , REG_IMAGECAL           , 0x02 },\
    { MODEM_FSK , REG_DIOMAPPING1        , 0x00 },\
    { MODEM_FSK , REG_DIOMAPPING2        , 0x30 },\
    { MODEM_LORA, REG_LR_PAYLOADMAXLENGTH, 0x40 },\
}                                     


/*!
 * Radio registers definition
 */
typedef struct
{
    RadioModems_t Modem;
    uint8_t       Addr;
    uint8_t       Value;
}RadioRegisters_t;

/*!
 * FSK bandwidth definition
 */
typedef struct
{
    uint32_t bandwidth;
    uint8_t  RegValue;
}FskBandwidth_t;

/*!
 * Radio hardware registers initialization
 *
 * \remark RADIO_INIT_REGISTERS_VALUE is defined in sx1276-board.h file
 */
const RadioRegisters_t RadioRegsInit[] = RADIO_INIT_REGISTERS_VALUE;

#define CAD_MASK			1
#define CAD_NODETECTED		0
#define CAD_DETECTED 		1
//#define CAD_SET_FLAG(val, flag)	(val | CAD_DETECTED)

#define SX127X_DRIVERNAME    "sx1278"
#define SX127X_CLASSNAME    "sx1278"
#define SX127X_DEVICENAME    "sx1278%d"


static DECLARE_BITMAP(minors, DRV_MINOR);


static dev_t drv_dev_num = MKDEV(DRV_MAJOR, 0);
static struct cdev drv_cdev;
static struct class *drv_class;


//static const char* invalid = "invalid";
static const char* modstr[] = {"fsk", "lora"};
static const char* opmodestr[] = {"sleep", "standby", "fstx", "tx", "fsrx", "rx", "rxcontinuous", "rxsingle", "cad"};
//static unsigned bwmap[] = { 7800, 10400, 15600, 20800, 31250, 41700, 62500, 125000, 250000, 500000 };
static const char* paoutput[] = {"rfo", "pa_boost"};


static LIST_HEAD(device_list);
static DEFINE_MUTEX(device_list_lock);

static int sx127x_set_opmode(struct sx127x *sx127x_ptr, u8 opMode);


static int sx127x_reg_read(struct spi_device *spi, u16 reg, u8* result){
    u8 addr = reg & 0xff;
    int ret = spi_write_then_read(spi,
            &addr, 1,
            result, 1);
    dev_dbg(&spi->dev, "read: @%02x %02x\n", addr, *result);
    return ret;
}
#if 0
static int sx127x_reg_read16(struct spi_device *spi, u16 reg, u16* result){
    u8 addr = reg & 0xff;
    int ret = spi_write_then_read(spi,
            &addr, 1,
            result, 2);
    dev_dbg(&spi->dev, "read: @%02x %02x\n", addr, *result);
    return ret;
}
#endif
static int sx127x_reg_read24(struct spi_device *spi, u16 reg, u32* result){
    u8 addr = reg & 0xff, buf[3];
    int ret = spi_write_then_read(spi,
            &addr, 1,
            buf, 3);
    *result = (buf[0] << 16) | (buf[1] << 8) | buf[0];
    dev_dbg(&spi->dev, "read: @%02x %06x\n", addr, *result);
    return ret;
}

static int sx127x_reg_write(struct spi_device *spi, u16 reg, u8 value){
    u8 addr = SX127X_REGADDR(reg), buff[2];//, readback;
    int ret;
    buff[0] = SX127X_WRITEADDR(addr);
    buff[1] = value;
    dev_dbg(&spi->dev, "write: @%02x %02x\n", addr, value);
    ret = spi_write(spi, buff, 2);
//    ret = sx127x_reg_read(spi, reg, &readback);
//    if(readback != value){
//        dev_warn(&spi->dev, "read back does not match\n");
//    }
    return ret;
}
#if 0
static int sx127x_reg_write24(struct spi_device *spi, u16 reg, u32 value){
    u8 addr = SX127X_REGADDR(reg), buff[4];
    int ret;
    buff[0] = SX127X_WRITEADDR(addr);
    buff[1] = (value >> 16) & 0xff;
    buff[2] = (value >> 8) & 0xff;
    buff[3] = value & 0xff;
    dev_dbg(&spi->dev, "write: @%02x %06x\n", addr, value);
    ret = spi_write(spi, buff, sizeof(buff));
    return ret;
}
#endif
static int sx127x_fifo_readpkt(struct spi_device *spi, void *buffer, u8 *len){
    u8 addr = REG_LR_FIFO, pktstart, rxbytes, off, fifoaddr;
    size_t maxtransfer = 0xFFFFFFFF;//spi_max_transfer_size(spi);
    int ret;
    unsigned readlen;
    ret = sx127x_reg_read(spi, REG_LR_FIFORXCURRENTADDR, &pktstart);
    ret = sx127x_reg_read(spi, REG_LR_RXNBBYTES, &rxbytes);
    for(off = 0; off < rxbytes; off += maxtransfer){
        readlen = min(maxtransfer, (size_t) (rxbytes - off));
        fifoaddr = pktstart + off;
        ret = sx127x_reg_write(spi, REG_LR_FIFOADDRPTR, fifoaddr);
        if(ret){
            break;
        }
        dev_warn(&spi->dev, "fifo read: %02x from %02x\n", readlen, fifoaddr);
        ret = spi_write_then_read(spi,
                &addr, 1,
                buffer + off, readlen);
        if(ret){
            break;
        }

    }
    //print_hex_dump_bytes("", DUMP_PREFIX_NONE, buffer, rxbytes);
    *len = rxbytes;
    return ret;
}

static int sx127x_fifo_writepkt(struct spi_device *spi, void *buffer, u8 len){
    u8 addr = SX127X_WRITEADDR(SX127X_REGADDR(REG_LR_FIFO));
    int ret;
    struct spi_transfer fifotransfers[] = {
            {.tx_buf = &addr, .len = 1},
            {.tx_buf = buffer, .len = len},
    };

    u8 readbackaddr = SX127X_REGADDR(REG_LR_FIFO);
    u8 readbackbuff[256];
    struct spi_transfer readbacktransfers[] = {
            {.tx_buf = &readbackaddr, .len = 1},
            {.rx_buf = &readbackbuff, .len = len},
    };

    ret = sx127x_reg_write(spi, REG_LR_FIFOTXBASEADDR, 0);
    ret = sx127x_reg_write(spi, REG_LR_FIFOADDRPTR, 0);
    ret = sx127x_reg_write(spi, REG_LR_PAYLOADLENGTH, len);

    dev_info(&spi->dev, "fifo write: %d\n", len);
    //print_hex_dump(KERN_DEBUG, NULL, DUMP_PREFIX_NONE, 16, 1, buffer, len, true);
    spi_sync_transfer(spi, fifotransfers, ARRAY_SIZE(fifotransfers));

    ret = sx127x_reg_write(spi, REG_LR_FIFOADDRPTR, 0);
    spi_sync_transfer(spi, readbacktransfers, ARRAY_SIZE(readbacktransfers));
    if(memcmp(buffer, readbackbuff, len) != 0){
        dev_err(&spi->dev, "fifo readback doesn't match\n");
    }
    return ret;
}

static irqreturn_t sx127x_dio0_top_irq_handler(int irq, void *dev_id)
{
    //struct sx127x *data = dev_id;
    disable_irq_nosync(irq);
    //schedule_work(&data->irq_work);
   return IRQ_WAKE_THREAD;
}

static irqreturn_t sx127x_dio0_bottem_irq_thread(int irq, void *dev_id)
{
    //struct sx127x *data = container_of(work, struct sx127x, irq_work);
    u32 fei;
    u8 irqflags, buf[128], len, snr, rssi;
    struct sx127x *data = dev_id;
    struct spi_device *spi = to_spi_device(data->dev);
    struct sx127x_pkt pkt;
    
    mutex_lock(&data->mutex);
    sx127x_reg_read(spi, REG_LR_IRQFLAGS, &irqflags);
    if(irqflags & RFLR_IRQFLAGS_RXDONE){
        u32 freq = data->cfg.LoRa.rChannel;
        //dev_warn(data->dev, "reading packet\n");
        memset(&pkt, 0, sizeof(pkt));

        sx127x_fifo_readpkt(spi, buf, &len);
        sx127x_reg_read(spi, REG_LR_PKTSNRVALUE, &snr);
        if(snr & 0x80 ) // The SNR sign bit is 1
        {
            // Invert and divide by 4
            snr = ( ( ~snr + 1 ) & 0xFF ) >> 2;
            snr = -snr;
        }
        else
        {
            // Divide by 4
            snr = ( snr & 0xFF ) >> 2;
        }
        sx127x_reg_read(spi, REG_LR_PKTRSSIVALUE, &rssi);
        sx127x_reg_read24(spi, REG_LR_FEIMSB, &fei);
        if(snr < 0)
        {
            if(freq > RF_MID_BAND_THRESH)
            {
                rssi = RSSI_OFFSET_HF + rssi + (rssi >> 4) + snr;
            }
            else
            {
                rssi = RSSI_OFFSET_LF + rssi + (rssi >> 4) + snr;
            }
        }
        else
        {
            if(freq > RF_MID_BAND_THRESH)
            {
                rssi = RSSI_OFFSET_HF + rssi + (rssi >> 4);
            }
            else
            {
                rssi = RSSI_OFFSET_LF + rssi + (rssi >> 4);
            }
        }
        pkt.hdrlen = sizeof(pkt);
        pkt.payloadlen = len;
        pkt.len = pkt.hdrlen + pkt.payloadlen;
        pkt.snr = (__s16)(snr << 2) / 4 ;
        pkt.rssi = -157 + rssi; //TODO fix this for the LF port

        if(irqflags & RFLR_IRQFLAGS_PAYLOADCRCERROR){
            dev_warn(data->dev, "CRC Error for received payload\n");
            pkt.crcfail = 1;
        }

        kfifo_in(&data->out, &pkt, sizeof(pkt));
        kfifo_in(&data->out, buf, len);
        wake_up(&data->readwq);
    }
    else if(irqflags & RFLR_IRQFLAGS_TXDONE){
        //if(data->gpio_txen){
        //    gpiod_set_value(data->gpio_txen, 0);
        //}
        //dev_warn(data->dev, "transmitted packet\n");
        /* after tx the chip goes back to standby so restore the user selected mode if it wasn't standby */
        //if(data->opmode != SX127X_OPMODE_STANDBY){
            //dev_info(data->dev, "restoring opmode\n");
            sx127x_set_opmode(data, RF_OPMODE_STANDBY);
        //}
        data->transmitted = 1;
        wake_up(&data->writewq);
    }
    else {
        dev_err(data->dev, "unhandled interrupt state %02x\n", (unsigned) irqflags);
    }
    sx127x_reg_write(spi, REG_LR_IRQFLAGS, 0xff);
    mutex_unlock(&data->mutex);
    enable_irq(irq);

    return IRQ_HANDLED;
}

static irqreturn_t sx127x_dio1_top_irq_handler(int irq, void *dev_id)
{
    //struct sx127x *data = dev_id;
    printk(KERN_ERR "DIO1 IRQ\n");
    disable_irq_nosync(irq);
    //schedule_work(&data->irq_work);
    return IRQ_WAKE_THREAD;
}

static irqreturn_t sx127x_dio1_bottem_irq_thread(int irq, void *dev_id)
{
    printk(KERN_ERR "DIO1 IRQ\n");
    return IRQ_HANDLED;
}

static irqreturn_t sx127x_dio2_top_irq_handler(int irq, void *dev_id)
{
    //struct sx127x *data = dev_id;
    printk(KERN_ERR "DIO2 IRQ\n");
    disable_irq_nosync(irq);
    //schedule_work(&data->irq_work);
    return IRQ_WAKE_THREAD;
}

static irqreturn_t sx127x_dio2_bottem_irq_thread(int irq, void *dev_id)
{
    printk(KERN_ERR "DIO2 IRQ\n");
    enable_irq(irq);
    return IRQ_HANDLED;
}

static irqreturn_t sx127x_dio3_top_irq_handler(int irq, void *dev_id)
{
    //struct sx127x *data = dev_id;
    printk(KERN_ERR "DIO3 IRQ\n");
    disable_irq_nosync(irq);
    //schedule_work(&data->irq_work);
    return IRQ_WAKE_THREAD;
}

static irqreturn_t sx127x_dio3_bottem_irq_thread(int irq, void *dev_id)
{
    u8 irqflags = 0;
    struct sx127x *data = dev_id;
    struct spi_device *spi = to_spi_device(data->dev);
    
    mutex_lock(&data->mutex);
    sx127x_reg_read(spi, REG_LR_IRQFLAGS, &irqflags);
    if(irqflags & RFLR_IRQFLAGS_CADDONE){
        if(irqflags & RFLR_IRQFLAGS_CADDETECTED){
            dev_info(data->dev, "CAD done, detected activity\n");
			data->caddone = 2;
			wake_up(&data->readwq);
        }
        else {
            dev_info(data->dev, "CAD done, nothing detected\n");
			data->caddone = 1;
			wake_up(&data->readwq);
        }
    }
    else {
        dev_err(data->dev, "unhandled interrupt state %02x\n", (unsigned) irqflags);
    }
    sx127x_reg_write(spi, REG_LR_IRQFLAGS, 0xff);
    mutex_unlock(&data->mutex);
    enable_irq(irq);
    return IRQ_HANDLED;
}

static irqreturn_t sx127x_dio4_top_irq_handler(int irq, void *dev_id)
{
    //struct sx127x *data = dev_id;
    printk(KERN_ERR "DIO4 IRQ\n");
    disable_irq_nosync(irq);
    //schedule_work(&data->irq_work);
    return IRQ_WAKE_THREAD;
}

static irqreturn_t sx127x_dio4_bottem_irq_thread(int irq, void *dev_id)
{
    printk(KERN_ERR "DIO4 IRQ\n");
    enable_irq(irq);
    return IRQ_HANDLED;
}

#if 0
static int sx127x_io_init(struct sx127x_platform_data *plat_data_ptr)
{
    int result = 0;
    
    if(NULL == plat_data_ptr)
    {
        result = -ENOMEM;
        goto ERR_EXIT;
    }
   
    if(IS_ERR(plat_data_ptr->gpio_dio0))
    {
        result = gpio_request(desc_to_gpio(plat_data_ptr->gpio_dio0), "dio0");
        if(result < 0)
        {
            printk(KERN_ERR "gpio_request DIO0 error\n");
            goto ERR_EXIT;
        }
    }

    if(IS_ERR(plat_data_ptr->gpio_dio1))
    {
        result = gpio_request(desc_to_gpio(plat_data_ptr->gpio_dio1), "dio1");
        if(result < 0)
        {
            printk(KERN_ERR "gpio_request DIO1 error\n");
            goto ERR_EXIT1;
        }
    }

    if(IS_ERR(plat_data_ptr->gpio_dio2))
    {
        result = gpio_request(desc_to_gpio(plat_data_ptr->gpio_dio2), "dio2");
        if(result < 0)
        {
            printk(KERN_ERR "gpio_request DIO2 error\n");
            goto ERR_EXIT2;
        }
    }

    if(IS_ERR(plat_data_ptr->gpio_dio3))
    {
        result = gpio_request(desc_to_gpio(plat_data_ptr->gpio_dio3), "dio3");
        if(result < 0)
        {
            printk(KERN_ERR "gpio_request DIO3 error\n");
            goto ERR_EXIT3;
        }
    }

    if(IS_ERR(plat_data_ptr->gpio_dio4))
    {
        result = gpio_request(desc_to_gpio(plat_data_ptr->gpio_dio4), "dio4");
        if(result < 0)
        {
            printk(KERN_ERR "gpio_request DIO4 error\n");
            goto ERR_EXIT4;
        }
    }

    if(IS_ERR(plat_data_ptr->gpio_reset))
    {
        result = gpio_request(desc_to_gpio(plat_data_ptr->gpio_reset), "reset");
        if(result < 0)
        {
            printk(KERN_ERR "gpio_request RESET error\n");
            goto ERR_EXIT5;
        }
    }

    return result;
ERR_EXIT5:
    if(IS_ERR(plat_data_ptr->gpio_dio4))
        gpio_free(desc_to_gpio(plat_data_ptr->gpio_dio4));
ERR_EXIT4:
    if(IS_ERR(plat_data_ptr->gpio_dio3))
        gpio_free(desc_to_gpio(plat_data_ptr->gpio_dio3));
ERR_EXIT3:
    if(IS_ERR(plat_data_ptr->gpio_dio2))
        gpio_free(desc_to_gpio(plat_data_ptr->gpio_dio2));
ERR_EXIT2:
    if(IS_ERR(plat_data_ptr->gpio_dio1))
        gpio_free(desc_to_gpio(plat_data_ptr->gpio_dio1));
ERR_EXIT1:
    if(IS_ERR(plat_data_ptr->gpio_dio0))
        gpio_free(desc_to_gpio(plat_data_ptr->gpio_dio0));
ERR_EXIT:
    return result;
}
#endif
int sx127x_irq_init(struct sx127x *sx127x_ptr)
{
    int ret = 0;

    if(NULL == sx127x_ptr)
    {
        ret = -ENOMEM;
        goto ERR_EXIT0;
    }

    if(sx127x_ptr->plat_data.irq_gpio_dio0)
    {
        ret = devm_request_threaded_irq(sx127x_ptr->dev, sx127x_ptr->plat_data.irq_gpio_dio0, sx127x_dio0_top_irq_handler, 
                                        sx127x_dio0_bottem_irq_thread, IRQF_TRIGGER_RISING, DRV_NAME, sx127x_ptr);
        if(ret < 0)
        {
            goto ERR_EXIT0;
        }
    }

    if(sx127x_ptr->plat_data.irq_gpio_dio1)
    {
        ret = devm_request_threaded_irq(sx127x_ptr->dev, sx127x_ptr->plat_data.irq_gpio_dio1, sx127x_dio1_top_irq_handler, 
                                        sx127x_dio1_bottem_irq_thread, IRQF_TRIGGER_RISING, DRV_NAME, sx127x_ptr);

        if(ret)     
        {       
            printk(KERN_ERR "%s %d request_irq ERROR\n", __FUNCTION__, __LINE__);
            ret = -EFAULT;
            goto ERR_EXIT1; 
        }
    }

    if(sx127x_ptr->plat_data.irq_gpio_dio2)
    {
        ret = devm_request_threaded_irq(sx127x_ptr->dev, sx127x_ptr->plat_data.irq_gpio_dio2, sx127x_dio2_top_irq_handler, 
                                        sx127x_dio2_bottem_irq_thread, IRQF_TRIGGER_RISING, DRV_NAME, sx127x_ptr);
        if(ret)     
        {       
            printk(KERN_ERR "%s %d request_irq ERROR\n", __FUNCTION__, __LINE__);
            ret = -EFAULT;
            goto ERR_EXIT2; 
        }
    }

    if(sx127x_ptr->plat_data.irq_gpio_dio3)
    {
        ret = devm_request_threaded_irq(sx127x_ptr->dev, sx127x_ptr->plat_data.irq_gpio_dio3, sx127x_dio3_top_irq_handler, 
                                        sx127x_dio3_bottem_irq_thread, IRQF_TRIGGER_RISING, DRV_NAME, sx127x_ptr);
        if(ret)     
        {       
            printk(KERN_ERR "%s %d request_irq ERROR\n", __FUNCTION__, __LINE__);
            ret = -EFAULT;
            goto ERR_EXIT3; 
        }
    }

    if(sx127x_ptr->plat_data.irq_gpio_dio4)
    {
        ret = devm_request_threaded_irq(sx127x_ptr->dev, sx127x_ptr->plat_data.irq_gpio_dio4, sx127x_dio4_top_irq_handler, 
                                        sx127x_dio4_bottem_irq_thread, IRQF_TRIGGER_RISING, DRV_NAME, sx127x_ptr);
        if(ret)     
        {       
            printk(KERN_ERR "%s %d request_irq ERROR\n", __FUNCTION__, __LINE__);
            ret = -EFAULT;
            goto ERR_EXIT4; 
        }
    }

    return ret;

ERR_EXIT4:
    if(sx127x_ptr->plat_data.irq_gpio_dio3)
    {
        devm_free_irq(sx127x_ptr->dev, sx127x_ptr->plat_data.irq_gpio_dio3, sx127x_ptr);    
    }
ERR_EXIT3:
    if(sx127x_ptr->plat_data.irq_gpio_dio2)
    {
        devm_free_irq(sx127x_ptr->dev, sx127x_ptr->plat_data.irq_gpio_dio2, sx127x_ptr);
    }
ERR_EXIT2:
    if(sx127x_ptr->plat_data.irq_gpio_dio1)
    {
        devm_free_irq(sx127x_ptr->dev, sx127x_ptr->plat_data.irq_gpio_dio1, sx127x_ptr);
    }
ERR_EXIT1:
    if(sx127x_ptr->plat_data.irq_gpio_dio0)
    {
        devm_free_irq(sx127x_ptr->dev, sx127x_ptr->plat_data.irq_gpio_dio0, sx127x_ptr);
    }
ERR_EXIT0:
    
    return ret;
}

int sx127x_io_deinit(struct sx127x_platform_data *plat_data_ptr)
{
    int result = 0;

    if(NULL == plat_data_ptr)
    {
        result = -ENOMEM;
        goto ERR_EXIT;
    }

    if(IS_ERR(plat_data_ptr->gpio_dio0))
    {
        gpio_free(desc_to_gpio(plat_data_ptr->gpio_dio0));
    }
    
    if(IS_ERR(plat_data_ptr->gpio_dio1))
    {
        gpio_free(desc_to_gpio(plat_data_ptr->gpio_dio0));
    }

    if(IS_ERR(plat_data_ptr->gpio_dio2))
    {
        gpio_free(desc_to_gpio(plat_data_ptr->gpio_reset));
    }

    if(IS_ERR(plat_data_ptr->gpio_dio3))
    {
        gpio_free(desc_to_gpio(plat_data_ptr->gpio_reset));
    }

    if(IS_ERR(plat_data_ptr->gpio_dio4))
    {
        gpio_free(desc_to_gpio(plat_data_ptr->gpio_reset));
    }
   
    if(IS_ERR(plat_data_ptr->gpio_reset))
    {
        gpio_free(desc_to_gpio(plat_data_ptr->gpio_reset));
    }
    
ERR_EXIT:

    return result;
}

int sx127x_irq_deinit(struct sx127x *sx127x_ptr)
{
    int result = 0;

    if(NULL == sx127x_ptr)
    {
        result = -ENOMEM;
        goto ERR_EXIT;
    }

    if(sx127x_ptr->plat_data.irq_gpio_dio0)
    {
        devm_free_irq(sx127x_ptr->dev, sx127x_ptr->plat_data.irq_gpio_dio0, sx127x_ptr);
    }

    if(sx127x_ptr->plat_data.irq_gpio_dio1)
    {
       devm_free_irq(sx127x_ptr->dev, sx127x_ptr->plat_data.irq_gpio_dio1, sx127x_ptr);
    }

    if(sx127x_ptr->plat_data.irq_gpio_dio2)
    {
        devm_free_irq(sx127x_ptr->dev, sx127x_ptr->plat_data.irq_gpio_dio2, sx127x_ptr);
    }

    if(sx127x_ptr->plat_data.irq_gpio_dio3)
    {
        devm_free_irq(sx127x_ptr->dev, sx127x_ptr->plat_data.irq_gpio_dio3, sx127x_ptr);
    }
    
    if(sx127x_ptr->plat_data.irq_gpio_dio4)
    {
        devm_free_irq(sx127x_ptr->dev, sx127x_ptr->plat_data.irq_gpio_dio4, sx127x_ptr);
    }
ERR_EXIT:
    
    return result;
}


static int sx127x_parse_dt(struct device *dev_ptr, struct sx127x_platform_data *platdata_ptr)
{
    int result = 0;

    if ((NULL == dev_ptr) || (NULL == platdata_ptr))
    {
        result = -ENOMEM;
        goto ERR_EXIT;
    }
    
    platdata_ptr->gpio_dio0 = devm_gpiod_get(dev_ptr, "dio0");
    platdata_ptr->gpio_dio1 = devm_gpiod_get(dev_ptr, "dio1");
    platdata_ptr->gpio_dio2 = devm_gpiod_get(dev_ptr, "dio2");
    platdata_ptr->gpio_dio3 = devm_gpiod_get(dev_ptr, "dio3");
    platdata_ptr->gpio_dio4 = devm_gpiod_get(dev_ptr, "dio4");
    platdata_ptr->gpio_reset= devm_gpiod_get(dev_ptr, "reset");
    if(!IS_ERR(platdata_ptr->gpio_dio0))
    {
        platdata_ptr->irq_gpio_dio0 = gpio_to_irq(desc_to_gpio(platdata_ptr->gpio_dio0));
    }

    if(!IS_ERR(platdata_ptr->gpio_dio1))
    {
        platdata_ptr->irq_gpio_dio1 = gpiod_to_irq(platdata_ptr->gpio_dio1);
    }

    if(!IS_ERR(platdata_ptr->gpio_dio2))
    {
        platdata_ptr->irq_gpio_dio2 = gpiod_to_irq(platdata_ptr->gpio_dio2);
    }

    if(!IS_ERR(platdata_ptr->gpio_dio3))
    {
        platdata_ptr->irq_gpio_dio3 = gpiod_to_irq(platdata_ptr->gpio_dio3);
    }

    if(!IS_ERR(platdata_ptr->gpio_dio4))
    {
        platdata_ptr->irq_gpio_dio4 = gpiod_to_irq(platdata_ptr->gpio_dio4);
    }

    
ERR_EXIT:

    return result;
}



int sx127x_reset(struct sx127x_platform_data *platdata_ptr)
{
    int ret = 0;

    if(NULL == platdata_ptr)
    {
        ret = -ENOMEM;
        goto error;
    }

    gpiod_set_value(platdata_ptr->gpio_reset, 1);
    
    mdelay(1);
    
    gpiod_set_value(platdata_ptr->gpio_reset, 0);
    
    mdelay(6);

error:
    return ret;
}

static int sx127x_set_freq(struct sx127x *sx127x_ptr, u32 freq)
{
    int ret = 0;
    struct spi_device *spi = to_spi_device(sx127x_ptr->dev);
    u64 temp_freq = 0;
    u64 freq_step = FREQ_STEP;
    u32 temp_freq_step;
    
    do_div(freq_step, 5);   
    temp_freq_step = (u32)freq_step;
 
    temp_freq = (u64)freq * 100000000;
    do_div(temp_freq, temp_freq_step);
    
    freq = ( u32 )temp_freq / 5;
    
    ret = sx127x_reg_write(spi, REG_FRFMSB, (u8)((freq >> 16) & 0xFF));
    
    ret = sx127x_reg_write(spi, REG_FRFMID, (u8)((freq >> 8) & 0xFF));
    
    ret = sx127x_reg_write(spi, REG_FRFLSB, (u8)(freq & 0xFF));
    
    return ret;
}

static int sx127x_get_opmode(struct sx127x *sx127x_ptr, u8 *opMode)
{
    int ret = 0;
    u8 reg = 0;
    struct spi_device *spi = to_spi_device(sx127x_ptr->dev);

    sx127x_reg_read(spi, REG_OPMODE, &reg);
    
    *opMode = reg | RF_OPMODE_MASK;

    return ret;
}


static int sx127x_set_opmode(struct sx127x *sx127x_ptr, u8 opMode)
{
    int ret = 0;
    u8 reg = 0;
    struct spi_device *spi = to_spi_device(sx127x_ptr->dev);
    
    if( opMode == RF_OPMODE_SLEEP )
    {
        //SX1276SetAntSwLowPower( true );
    }
    else
    {
        //SX1276SetAntSwLowPower( false );
        //SX1276SetAntSw( opMode );
    }

    sx127x_reg_read(spi, REG_OPMODE, &reg);
    
    sx127x_reg_write(spi, REG_OPMODE, ((reg&RF_OPMODE_MASK)|opMode));

    return ret;
}

static int sx127x_set_sleep(struct sx127x *sx127x_ptr)
{
    int ret = 0;
    
    sx127x_set_opmode(sx127x_ptr, RF_OPMODE_SLEEP);

    return ret;
}

#if 0
static int sx127x_set_stby(struct sx127x *sx127x_ptr)
{
    int ret = 0;

    sx127x_set_opmode(sx127x_ptr, RF_OPMODE_STANDBY );

    return ret;
}
#endif
static int sx127x_get_modem(struct sx127x *sx127x_ptr, RadioModems_t *modem)
{
    u8 reg = 0;
    int ret = 0;

    struct spi_device *spi = to_spi_device(sx127x_ptr->dev);

    ret = sx127x_reg_read(spi, REG_OPMODE, &reg);
    if((reg&RFLR_OPMODE_LONGRANGEMODE_ON) != 0)
    {
        *modem = MODEM_LORA;
    }
    else
    {
        *modem = MODEM_FSK;
    }

    return ret;
}


static int sx127x_set_modem(struct sx127x *sx127x_ptr, RadioModems_t modem)
{
    u8 reg = 0;
    int ret = 0;
    RadioModems_t curmodem;
    struct spi_device *spi = to_spi_device(sx127x_ptr->dev);

    ret = sx127x_reg_read(spi, REG_OPMODE, &reg);
    if((reg&RFLR_OPMODE_LONGRANGEMODE_ON) != 0)
    {
        curmodem = MODEM_LORA;
    }
    else
    {
        curmodem = MODEM_FSK;
    }

    if(curmodem == modem )
    {
        return ret;
    }

    switch(modem)
    {
    default:
    case MODEM_FSK:
        sx127x_set_sleep(sx127x_ptr);
        ret = sx127x_reg_read(spi, REG_OPMODE, &reg);
        sx127x_reg_write(spi, REG_OPMODE, (reg&RFLR_OPMODE_LONGRANGEMODE_MASK)|RFLR_OPMODE_LONGRANGEMODE_OFF);

        sx127x_reg_write(spi, REG_DIOMAPPING1, 0x00);
        sx127x_reg_write(spi, REG_DIOMAPPING2, 0x30); // DIO5=ModeReady
        break;
    case MODEM_LORA:
        sx127x_set_sleep(sx127x_ptr);
        ret = sx127x_reg_read(spi, REG_OPMODE, &reg);
        sx127x_reg_write(spi, REG_OPMODE, (reg&RFLR_OPMODE_LONGRANGEMODE_MASK)|RFLR_OPMODE_LONGRANGEMODE_ON);

        sx127x_reg_write(spi, REG_DIOMAPPING1, 0x00 );
        sx127x_reg_write(spi, REG_DIOMAPPING2, 0x00 );
        break;
    }

    return ret;
}

/*!
 * Performs the Rx chain calibration for LF and HF bands
 * \remark Must be called just after the reset so all registers are at their
 *         default values
 */
static int RxChainCalibration(struct sx127x *sx127x_ptr)
{
    int result = 0;
    uint8_t regval0 = 0, regval1 = 0, regval2 = 0;
    uint8_t regPaConfigInitVal = 0;
    uint32_t initialFreq = 0;
    uint64_t temp = 0;
    struct spi_device *spi = to_spi_device(sx127x_ptr->dev);

    // Save context
    result = sx127x_reg_read(spi, REG_PACONFIG, &regPaConfigInitVal);
    if(result < 0)
    {
        goto ERR_EXIT;
    }

    result = sx127x_reg_read(spi, REG_FRFMSB, &regval0);
    if(result < 0)
    {
        goto ERR_EXIT;
    }
    
    result = sx127x_reg_read(spi, REG_FRFMID, &regval1);
    if(result < 0)
    {
        goto ERR_EXIT;
    }
    
    result = sx127x_reg_read(spi, REG_FRFLSB, &regval2);
    if(result < 0)
    {
        goto ERR_EXIT;
    }

    temp = (((uint32_t)regval0 << 16) | ((uint32_t)regval1 << 8) | (uint32_t)regval2) * FREQ_STEP;

    do_div(temp, 100000000);

    initialFreq = (uint32_t)temp;

    // Cut the PA just in case, RFO output, power = -1 dBm
    result = sx127x_reg_write(spi, REG_PACONFIG, 0x00);
    if(result < 0)
    {
        goto ERR_EXIT;
    }

    // Launch Rx chain calibration for LF band
    result = sx127x_reg_read(spi, REG_IMAGECAL, &regval0);
    if(result < 0)
    {
        goto ERR_EXIT;
    }

    result = sx127x_reg_write(spi, REG_IMAGECAL, (regval0 & RF_IMAGECAL_IMAGECAL_MASK)|RF_IMAGECAL_IMAGECAL_START);
    if(result < 0)
    {
        goto ERR_EXIT;
    }

    result = sx127x_reg_read(spi, REG_IMAGECAL, &regval0);
    if(result < 0)
    {
        goto ERR_EXIT;
    }
    while((regval0&RF_IMAGECAL_IMAGECAL_RUNNING) == RF_IMAGECAL_IMAGECAL_RUNNING)
    {
        result = sx127x_reg_read(spi, REG_IMAGECAL, &regval0);
        if(result < 0)
        {
            goto ERR_EXIT;
        }
    }

    // Sets a Frequency in HF band
    result = sx127x_set_freq(sx127x_ptr, 868000000);
    if(result < 0)
    {
        goto ERR_EXIT;
    }

    // Launch Rx chain calibration for HF band
    result = sx127x_reg_read(spi, REG_IMAGECAL, &regval0);
    if(result < 0)
    {
        goto ERR_EXIT;
    }
    
    result = sx127x_reg_write(spi, REG_IMAGECAL, (regval0 &RF_IMAGECAL_IMAGECAL_MASK)|RF_IMAGECAL_IMAGECAL_START);
    if(result < 0)
    {
        goto ERR_EXIT;
    }

    result = sx127x_reg_read(spi, REG_IMAGECAL, &regval0);
    if(result < 0)
    {
        goto ERR_EXIT;
    }
    
    while((regval0&RF_IMAGECAL_IMAGECAL_RUNNING) == RF_IMAGECAL_IMAGECAL_RUNNING)
    {
        result = sx127x_reg_read(spi, REG_IMAGECAL, &regval0);
        if(result < 0)
        {
            goto ERR_EXIT;
        }
    }

    // Restore context
    result = sx127x_reg_write(spi, REG_PACONFIG, regPaConfigInitVal);
    if(result < 0)
    {
        goto ERR_EXIT;
    }
    
    result = sx127x_set_freq(sx127x_ptr, initialFreq);
    if(result < 0)
    {
        goto ERR_EXIT;
    }

ERR_EXIT:

    return result;
}


#define RF_MID_BAND_THRESH                          525000000

u8 sx127x_get_paselect(u32 channel)
{
    if(channel < RF_MID_BAND_THRESH)
    {
        return RF_PACONFIG_PASELECT_PABOOST;
    }
    else
    {
        return RF_PACONFIG_PASELECT_RFO;
    }
}

int sx127x_set_txpower(struct sx127x *sx127x_ptr, uint32_t freq, int power)
{
    int result = 0;
    u8 paConfig = 0;
    u8 paDac = 0;
    struct spi_device *spi = to_spi_device(sx127x_ptr->dev);

    result = sx127x_reg_read(spi ,REG_PACONFIG, &paConfig);
    if(result < 0)
    {
        goto ERR_EXIT;
    }
    
    result = sx127x_reg_read(spi ,REG_PADAC, &paDac);
    if(result < 0)
    {
        goto ERR_EXIT;
    }

    paConfig = ( paConfig & RF_PACONFIG_PASELECT_MASK ) | sx127x_get_paselect(freq);
    paConfig = ( paConfig & RF_PACONFIG_MAX_POWER_MASK ) | 0x70;

    if( ( paConfig & RF_PACONFIG_PASELECT_PABOOST ) == RF_PACONFIG_PASELECT_PABOOST )
    {
        if( power > 17 )
        {
            paDac = ( paDac & RF_PADAC_20DBM_MASK ) | RF_PADAC_20DBM_ON;
        }
        else
        {
            paDac = ( paDac & RF_PADAC_20DBM_MASK ) | RF_PADAC_20DBM_OFF;
        }
        if( ( paDac & RF_PADAC_20DBM_ON ) == RF_PADAC_20DBM_ON )
        {
            if( power < 5 )
            {
                power = 5;
            }
            if( power > 20 )
            {
                power = 20;
            }
            paConfig = ( paConfig & RF_PACONFIG_OUTPUTPOWER_MASK ) | ( u8 )( ( u16 )( power - 5 ) & 0x0F );
        }
        else
        {
            if( power < 2 )
            {
                power = 2;
            }
            if( power > 17 )
            {
                power = 17;
            }
            paConfig = ( paConfig & RF_PACONFIG_OUTPUTPOWER_MASK ) | ( u8 )( ( u16 )( power - 2 ) & 0x0F );
        }
    }
    else
    {
        if( power < -1 )
        {
            power = -1;
        }
        if( power > 14 )
        {
            power = 14;
        }
        paConfig = ( paConfig & RF_PACONFIG_OUTPUTPOWER_MASK ) | ( u8 )( ( u16 )( power + 1 ) & 0x0F );
    }
    result = sx127x_reg_write(spi, REG_PACONFIG, paConfig);
    if(result < 0)
    {
        goto ERR_EXIT;
    }
    
    result = sx127x_reg_write(spi, REG_PADAC, paDac);
    if(result < 0)
    {
        goto ERR_EXIT;
    }

ERR_EXIT:

    return result;
}


int sx127x_init(struct sx127x *sx127x_ptr)
{
    int ret = 0;
    uint8_t i;
    struct spi_device *spi = to_spi_device(sx127x_ptr->dev);

    if(NULL == sx127x_ptr)
    {
        ret = -ENOMEM;
        goto error;
    }

    //sx127x_io_init(&sx127x_ptr->plat_data);
    
    ret = sx127x_reset(&sx127x_ptr->plat_data);
    if(ret < 0)
    {
        goto error;
    }

    RxChainCalibration(sx127x_ptr);

    sx127x_set_opmode(sx127x_ptr, RF_OPMODE_SLEEP);

    for(i = 0; i < sizeof(RadioRegsInit) / sizeof(RadioRegisters_t); i++)
    {
        sx127x_set_modem(sx127x_ptr, RadioRegsInit[i].Modem);
        sx127x_reg_write(spi, RadioRegsInit[i].Addr, RadioRegsInit[i].Value);
    }

    sx127x_irq_init(sx127x_ptr);

    sx127x_set_modem(sx127x_ptr, MODEM_LORA);

error:

    return ret;
}


static int sx127x_set_rxconfig(struct sx127x *sx127x_ptr, u32 freq, u32 bandwidth, u32 datarate, u32 coderate, u16 preambleLen)
{
    int ret = 0;
    u8 reg = 0;

    bool crcOn = true;
    bool fixLen = false;
    bool iqInverted = false;
    //bool rxContinuou = true;
    bool freqHopOn = false;
    u16 symbTimeout = 5;
    u8 payloadLen = 0;
    u8 hopPeriod = 0;
    u8 LowDatarateOptimize = 0;
    
    struct spi_device *spi = to_spi_device(sx127x_ptr->dev);

    ret = sx127x_set_freq(sx127x_ptr, freq);
    if(ret < 0)
    {
        goto error;
    }
    
    
    if( ( ( bandwidth == 7 ) && ( ( datarate == 11 ) || ( datarate == 12 ) ) ) ||
        ( ( bandwidth == 8 ) && ( datarate == 12 ) ) )
    {
        LowDatarateOptimize = 0x01;
    }
    else
    {
        LowDatarateOptimize = 0x00;
    }


    sx127x_reg_read(spi, REG_LR_MODEMCONFIG1, &reg);
    sx127x_reg_write(spi, REG_LR_MODEMCONFIG1,
                 ( reg &
                   RFLR_MODEMCONFIG1_BW_MASK &
                   RFLR_MODEMCONFIG1_CODINGRATE_MASK &
                   RFLR_MODEMCONFIG1_IMPLICITHEADER_MASK ) |
                   ( bandwidth << 4 ) | ( coderate << 1 ) |
                   fixLen );

    sx127x_reg_read(spi, REG_LR_MODEMCONFIG2, &reg);
    sx127x_reg_write(spi, REG_LR_MODEMCONFIG2,
                 ( reg &
                   RFLR_MODEMCONFIG2_SF_MASK &
                   RFLR_MODEMCONFIG2_RXPAYLOADCRC_MASK &
                   RFLR_MODEMCONFIG2_SYMBTIMEOUTMSB_MASK ) |
                   ( datarate << 4 ) | ( crcOn << 2 ) |
                   ( ( symbTimeout >> 8 ) & ~RFLR_MODEMCONFIG2_SYMBTIMEOUTMSB_MASK ) );

    sx127x_reg_read(spi, REG_LR_MODEMCONFIG3, &reg);
    sx127x_reg_write(spi, REG_LR_MODEMCONFIG3,
                 ( reg &
                   RFLR_MODEMCONFIG3_LOWDATARATEOPTIMIZE_MASK ) |
                   ( LowDatarateOptimize << 3 ) );

    sx127x_reg_write(spi, REG_LR_SYMBTIMEOUTLSB, ( u8 )( symbTimeout & 0xFF ) );

    sx127x_reg_write(spi, REG_LR_PREAMBLEMSB, ( u8 )( ( preambleLen >> 8 ) & 0xFF ) );
    sx127x_reg_write(spi, REG_LR_PREAMBLELSB, ( u8 )( preambleLen & 0xFF ) );

    if( fixLen == true )
    {
        sx127x_reg_write(spi, REG_LR_PAYLOADLENGTH, payloadLen );
    }

    if(freqHopOn == true )
    {
        sx127x_reg_read(spi, REG_LR_PLLHOP, &reg);
        sx127x_reg_write(spi, REG_LR_PLLHOP, ( reg & RFLR_PLLHOP_FASTHOP_MASK ) | RFLR_PLLHOP_FASTHOP_ON );
        sx127x_reg_write(spi, REG_LR_HOPPERIOD, hopPeriod );
    }

    if( ( bandwidth == 9 ) && ( freq > RF_MID_BAND_THRESH ) )
    {
        // ERRATA 2.1 - Sensitivity Optimization with a 500 kHz Bandwidth
        sx127x_reg_write(spi, REG_LR_TEST36, 0x02);
        sx127x_reg_write(spi, REG_LR_TEST3A, 0x64);
    }
    else if( bandwidth == 9 )
    {
        // ERRATA 2.1 - Sensitivity Optimization with a 500 kHz Bandwidth
        sx127x_reg_write(spi, REG_LR_TEST36, 0x02);
        sx127x_reg_write(spi, REG_LR_TEST3A, 0x7F);
    }
    else
    {
        // ERRATA 2.1 - Sensitivity Optimization with a 500 kHz Bandwidth
        sx127x_reg_write(spi, REG_LR_TEST36, 0x03);
    }

    if( datarate == 6 )
    {
        sx127x_reg_read(spi, REG_LR_DETECTOPTIMIZE, &reg);
        sx127x_reg_write(spi, REG_LR_DETECTOPTIMIZE,
                     (reg  &
                       RFLR_DETECTIONOPTIMIZE_MASK ) |
                       RFLR_DETECTIONOPTIMIZE_SF6 );
        sx127x_reg_write(spi, REG_LR_DETECTIONTHRESHOLD,
                     RFLR_DETECTIONTHRESH_SF6 );
    }
    else
    {
        sx127x_reg_read(spi, REG_LR_DETECTOPTIMIZE, &reg);
        sx127x_reg_write(spi, REG_LR_DETECTOPTIMIZE,
                     ( reg &
                     RFLR_DETECTIONOPTIMIZE_MASK ) |
                     RFLR_DETECTIONOPTIMIZE_SF7_TO_SF12 );
        sx127x_reg_write(spi, REG_LR_DETECTIONTHRESHOLD,
                     RFLR_DETECTIONTHRESH_SF7_TO_SF12 );
    }

    if(iqInverted == true)
    {
        sx127x_reg_read(spi, REG_LR_INVERTIQ, &reg) ;
        
        sx127x_reg_write(spi, REG_LR_INVERTIQ, ((reg & RFLR_INVERTIQ_TX_MASK & RFLR_INVERTIQ_RX_MASK) |
                                                RFLR_INVERTIQ_RX_ON | RFLR_INVERTIQ_TX_OFF));
        sx127x_reg_write(spi, REG_LR_INVERTIQ2, RFLR_INVERTIQ2_ON);
    }
    else
    {
        sx127x_reg_read(spi, REG_LR_INVERTIQ, &reg) ;
        
        sx127x_reg_write(spi, REG_LR_INVERTIQ, ((reg & RFLR_INVERTIQ_TX_MASK & RFLR_INVERTIQ_RX_MASK) | 
                                            RFLR_INVERTIQ_RX_OFF | RFLR_INVERTIQ_TX_OFF));
        sx127x_reg_write(spi, REG_LR_INVERTIQ2, RFLR_INVERTIQ2_OFF);
    }

    // ERRATA 2.3 - Receiver Spurious Reception of a LoRa Signal
    if(bandwidth < 9)
    {
        sx127x_reg_read(spi, REG_LR_DETECTOPTIMIZE, &reg);
        sx127x_reg_write(spi, REG_LR_DETECTOPTIMIZE, reg & 0x7F);
        sx127x_reg_write(spi, REG_LR_TEST30, 0x00);
        switch(bandwidth)
        {
        case 0: // 7.8 kHz
            sx127x_reg_write(spi, REG_LR_TEST2F, 0x48);
            sx127x_set_freq(sx127x_ptr, freq + 7810);
            break;
        case 1: // 10.4 kHz
            sx127x_reg_write(spi, REG_LR_TEST2F, 0x44);
            sx127x_set_freq(sx127x_ptr, freq + 10420 );
            break;
        case 2: // 15.6 kHz
            sx127x_reg_write(spi, REG_LR_TEST2F, 0x44);
            sx127x_set_freq(sx127x_ptr, freq + 15620 );
            break;
        case 3: // 20.8 kHz
            sx127x_reg_write(spi, REG_LR_TEST2F, 0x44);
            sx127x_set_freq(sx127x_ptr, freq + 20830 );
            break;
        case 4: // 31.2 kHz
            sx127x_reg_write(spi, REG_LR_TEST2F, 0x44);
            sx127x_set_freq(sx127x_ptr, freq + 31250);
            break;
        case 5: // 41.4 kHz
            sx127x_reg_write(spi, REG_LR_TEST2F, 0x44);
            sx127x_set_freq(sx127x_ptr, freq + 41670 );
            break;
        case 6: // 62.5 kHz
            sx127x_reg_write(spi, REG_LR_TEST2F, 0x40);
            break;
        case 7: // 125 kHz
            sx127x_reg_write(spi, REG_LR_TEST2F, 0x40);
            break;
        case 8: // 250 kHz
            sx127x_reg_write(spi,  REG_LR_TEST2F, 0x40);
            break;
        }
    }
    else
    {
        sx127x_reg_read(spi, REG_LR_DETECTOPTIMIZE, &reg);
        sx127x_reg_write(spi, REG_LR_DETECTOPTIMIZE, reg | 0x80 );
    }

    if(freqHopOn == true )
    {
        sx127x_reg_write(spi, REG_LR_IRQFLAGSMASK, //RFLR_IRQFLAGS_RXTIMEOUT |
                                          //RFLR_IRQFLAGS_RXDONE |
                                          //RFLR_IRQFLAGS_PAYLOADCRCERROR |
                                          RFLR_IRQFLAGS_VALIDHEADER |
                                          RFLR_IRQFLAGS_TXDONE |
                                          RFLR_IRQFLAGS_CADDONE |
                                          //RFLR_IRQFLAGS_FHSSCHANGEDCHANNEL |
                                          RFLR_IRQFLAGS_CADDETECTED);

        // DIO0=RxDone, DIO2=FhssChangeChannel
        sx127x_reg_read(spi, REG_DIOMAPPING1, &reg);
        sx127x_reg_write(spi, REG_DIOMAPPING1, (reg & RFLR_DIOMAPPING1_DIO0_MASK & RFLR_DIOMAPPING1_DIO2_MASK) | 
                                                RFLR_DIOMAPPING1_DIO0_00 | RFLR_DIOMAPPING1_DIO2_00);
    }
    else
    {
        sx127x_reg_write(spi, REG_LR_IRQFLAGSMASK, //RFLR_IRQFLAGS_RXTIMEOUT |
                                          //RFLR_IRQFLAGS_RXDONE |
                                          //RFLR_IRQFLAGS_PAYLOADCRCERROR |
                                          RFLR_IRQFLAGS_VALIDHEADER |
                                          RFLR_IRQFLAGS_TXDONE |
                                          RFLR_IRQFLAGS_CADDONE |
                                          RFLR_IRQFLAGS_FHSSCHANGEDCHANNEL |
                                          RFLR_IRQFLAGS_CADDETECTED);

        // DIO0=RxDone
        sx127x_reg_read(spi, REG_DIOMAPPING1, &reg);
        sx127x_reg_write(spi, REG_DIOMAPPING1, (reg & RFLR_DIOMAPPING1_DIO0_MASK) | RFLR_DIOMAPPING1_DIO0_00);
    }

error:
    
    return ret;
}


static int sx127x_set_txconfig(struct sx127x *sx127x_ptr, u32 freq, s8 power, u32 bandwidth, u32 datarate, u32 coderate, u16 preambleLen)
{
    int ret = 0;
    u8 reg = 0;
    bool crcOn = true;
    bool fixLen = false;
    bool freqHopOn = false;
    bool iqInverted = 0;
    u8 hopPeriod = 0; 
    bool LowDatarateOptimize = false;
    struct spi_device *spi = to_spi_device(sx127x_ptr->dev);

    ret = sx127x_set_freq(sx127x_ptr, freq);
    if(ret < 0)
    {
        goto error;
    }

    sx127x_set_txpower(sx127x_ptr, freq, power);
    
    if( datarate > 12 )
    {
        datarate = 12;
    }
    else if( datarate < 6 )
    {
        datarate = 6;
    }
    if( ( ( bandwidth == 7 ) && ( ( datarate == 11 ) || ( datarate == 12 ) ) ) ||
        ( ( bandwidth == 8 ) && ( datarate == 12 ) ) )
    {
        LowDatarateOptimize = 0x01;
    }
    else
    {
        LowDatarateOptimize = 0x00;
    }

    if( freqHopOn == true )
    {
        sx127x_reg_read(spi, REG_LR_PLLHOP, &reg);
        sx127x_reg_write(spi, REG_LR_PLLHOP, (reg & RFLR_PLLHOP_FASTHOP_MASK) | RFLR_PLLHOP_FASTHOP_ON);
        sx127x_reg_write(spi, REG_LR_HOPPERIOD, hopPeriod);
    }

    sx127x_reg_read(spi, REG_LR_MODEMCONFIG1, &reg);
    sx127x_reg_write(spi, REG_LR_MODEMCONFIG1,
                 ( reg &
                   RFLR_MODEMCONFIG1_BW_MASK &
                   RFLR_MODEMCONFIG1_CODINGRATE_MASK &
                   RFLR_MODEMCONFIG1_IMPLICITHEADER_MASK ) |
                   ( bandwidth << 4 ) | ( coderate << 1 ) |
                   fixLen );

    sx127x_reg_read(spi, REG_LR_MODEMCONFIG2, &reg);
    sx127x_reg_write(spi, REG_LR_MODEMCONFIG2,
                   (reg&
                   RFLR_MODEMCONFIG2_SF_MASK &
                   RFLR_MODEMCONFIG2_RXPAYLOADCRC_MASK ) |
                   ( datarate << 4 ) | ( crcOn << 2 ) );

    sx127x_reg_read(spi, REG_LR_MODEMCONFIG3, &reg);
    sx127x_reg_write(spi, REG_LR_MODEMCONFIG3,
                    (reg&
                    RFLR_MODEMCONFIG3_LOWDATARATEOPTIMIZE_MASK ) |
                    (LowDatarateOptimize << 3 ) );

    sx127x_reg_write(spi, REG_LR_PREAMBLEMSB, ( preambleLen >> 8 ) & 0x00FF );
    sx127x_reg_write(spi, REG_LR_PREAMBLELSB, preambleLen & 0xFF );

    if( datarate == 6 )
    {
        sx127x_reg_read(spi, REG_LR_DETECTOPTIMIZE, &reg);
        sx127x_reg_write(spi, REG_LR_DETECTOPTIMIZE,
                     ( reg &
                       RFLR_DETECTIONOPTIMIZE_MASK ) |
                       RFLR_DETECTIONOPTIMIZE_SF6 );
        sx127x_reg_write(spi, REG_LR_DETECTIONTHRESHOLD,
                     RFLR_DETECTIONTHRESH_SF6 );
    }
    else
    {
        sx127x_reg_read(spi, REG_LR_DETECTOPTIMIZE, &reg);
        sx127x_reg_write(spi, REG_LR_DETECTOPTIMIZE,
                     ( reg &
                     RFLR_DETECTIONOPTIMIZE_MASK ) |
                     RFLR_DETECTIONOPTIMIZE_SF7_TO_SF12 );
        sx127x_reg_write(spi, REG_LR_DETECTIONTHRESHOLD,
                     RFLR_DETECTIONTHRESH_SF7_TO_SF12 );
    }

    if(iqInverted == true)
    {
        sx127x_reg_read(spi, REG_LR_INVERTIQ, &reg) ;
        sx127x_reg_write(spi, REG_LR_INVERTIQ, ((reg& RFLR_INVERTIQ_TX_MASK & RFLR_INVERTIQ_RX_MASK) | 
                                                RFLR_INVERTIQ_RX_OFF | RFLR_INVERTIQ_TX_ON));
        sx127x_reg_write(spi, REG_LR_INVERTIQ2, RFLR_INVERTIQ2_ON );
    }
    else
    {
        sx127x_reg_read(spi, REG_LR_INVERTIQ, &reg);
        sx127x_reg_write(spi, REG_LR_INVERTIQ, ((reg & RFLR_INVERTIQ_TX_MASK & RFLR_INVERTIQ_RX_MASK) | 
                                                RFLR_INVERTIQ_RX_OFF | RFLR_INVERTIQ_TX_OFF));
        sx127x_reg_write(spi, REG_LR_INVERTIQ2, RFLR_INVERTIQ2_OFF);
    }
    


    if(freqHopOn == true)
    {
        sx127x_reg_write(spi, REG_LR_IRQFLAGSMASK, RFLR_IRQFLAGS_RXTIMEOUT |
                                          RFLR_IRQFLAGS_RXDONE |
                                          RFLR_IRQFLAGS_PAYLOADCRCERROR |
                                          RFLR_IRQFLAGS_VALIDHEADER |
                                          //RFLR_IRQFLAGS_TXDONE |
                                          RFLR_IRQFLAGS_CADDONE |
                                          //RFLR_IRQFLAGS_FHSSCHANGEDCHANNEL |
                                          RFLR_IRQFLAGS_CADDETECTED );

        // DIO0=TxDone, DIO2=FhssChangeChannel
        sx127x_reg_read(spi, REG_DIOMAPPING1, &reg);
        sx127x_reg_write(spi, REG_DIOMAPPING1, (reg & RFLR_DIOMAPPING1_DIO0_MASK & RFLR_DIOMAPPING1_DIO2_MASK ) | 
                                                RFLR_DIOMAPPING1_DIO0_01 | RFLR_DIOMAPPING1_DIO2_00 );
    }
    else
    {
        sx127x_reg_write(spi, REG_LR_IRQFLAGSMASK, RFLR_IRQFLAGS_RXTIMEOUT |
                                          RFLR_IRQFLAGS_RXDONE |
                                          RFLR_IRQFLAGS_PAYLOADCRCERROR |
                                          RFLR_IRQFLAGS_VALIDHEADER |
                                          //RFLR_IRQFLAGS_TXDONE |
                                          RFLR_IRQFLAGS_CADDONE |
                                          RFLR_IRQFLAGS_FHSSCHANGEDCHANNEL |
                                          RFLR_IRQFLAGS_CADDETECTED);

        // DIO0=TxDone
        sx127x_reg_read(spi, REG_DIOMAPPING1, &reg);
        sx127x_reg_write(spi, REG_DIOMAPPING1, (reg & RFLR_DIOMAPPING1_DIO0_MASK) | RFLR_DIOMAPPING1_DIO0_01);
    }
    
error:
    
    return ret;
}


static int sx127x_setrx(struct sx127x *sx127x_ptr)
{
    int ret = 0;
    bool rxContinuous = true;
    struct spi_device *spi = to_spi_device(sx127x_ptr->dev);

    if(NULL == sx127x_ptr)
    {
        goto error;
    }
    
    sx127x_reg_write(spi, REG_LR_FIFORXBASEADDR, 0);
    
    sx127x_reg_write(spi, REG_LR_FIFOADDRPTR, 0);


    if( rxContinuous == true )
    {
        sx127x_set_opmode(sx127x_ptr, RFLR_OPMODE_RECEIVER);
    }
    else
    {
        sx127x_set_opmode(sx127x_ptr, RFLR_OPMODE_RECEIVER_SINGLE);
    }

error:

    return ret;
}

#if 0
static int sx127x_read_snr_rssi(struct sx127x *sx127x_ptr, u32 freq, u8 *snr, u8 *rssi)
{
	int ret = 0;
    u8 regsnr = 0;
    u8 regrssi = 0;
	struct spi_device *spi = to_spi_device(sx127x_ptr->dev);
	
	sx127x_reg_read(spi, REG_LR_PKTSNRVALUE, &regsnr);
	if(regsnr & 0x80 ) // The SNR sign bit is 1
	{
		// Invert and divide by 4
		*snr = ( ( ~regsnr + 1 ) & 0xFF ) >> 2;
		*snr = -regsnr;
	}
	else
	{
		// Divide by 4
		*snr = ( regsnr & 0xFF ) >> 2;
	}
	sx127x_reg_read(spi, REG_LR_PKTRSSIVALUE, &regrssi);
	if(*snr < 0)
	{
		if(freq > RF_MID_BAND_THRESH)
		{
			*rssi = RSSI_OFFSET_HF + regrssi + (regrssi >> 4) + *snr;
		}
		else
		{
			*rssi = RSSI_OFFSET_LF + regrssi + (regrssi >> 4) + *snr;
		}
	}
	else
	{
		if(freq > RF_MID_BAND_THRESH)
		{
			*rssi = RSSI_OFFSET_HF + regrssi + (regrssi >> 4);
		}
		else
		{
			*rssi = RSSI_OFFSET_LF + regrssi + (regrssi >> 4);
		}
	}

	return ret;
}
#endif
int sx127x_read_rssi(struct sx127x *sx127x_ptr, u32 freq, int16_t *rssi)
{
	int ret = 0;
	u8 regrssi = 0;
    struct spi_device *spi = to_spi_device(sx127x_ptr->dev);
	
	ret = sx127x_reg_read(spi, REG_LR_RSSIVALUE, &regrssi);
	
	if(freq > RF_MID_BAND_THRESH)
	{
		*rssi = (int16_t)(RSSI_OFFSET_HF + regrssi);
	}
	else
	{
		*rssi = (int16_t)(RSSI_OFFSET_LF + regrssi);
	}
    
    return ret;
}

/*!
 * \brief Checks if the channel is free for the given time
 *
 * \param [IN] freq         Channel RF frequency
 *
 */
/******************************************************************************
*	Function: sx127x_detect_chan_rssi
*	Brief:	Checks if the channel is free for the given time
*	Param:
            sx127x_ptr			- the info of sx127x structure
			freq				- Channel RF frequency(uint :1Hz)
			rssiThresh			- the thershold value of rssi
			maxCarrierSenseTime - the max carrier detected time	
*	Return:	
			1					- Channel is not free
			0					- Channel is free
			< 0					- failed
*	Comment:	none
 ******************************************************************************/
int sx127x_detect_chan_rssi(struct sx127x *sx127x_ptr, u32 freq, s16 rssiThresh, u32 maxCarrierSenseTime)
{
    int ret = 0;
    s16 rssi = 0;
    unsigned long endjiffistime = jiffies + msecs_to_jiffies(maxCarrierSenseTime);

    sx127x_set_modem(sx127x_ptr, MODEM_LORA);

    sx127x_set_freq(sx127x_ptr, freq);

    sx127x_set_opmode(sx127x_ptr, RF_OPMODE_RECEIVER);

    mdelay(1);

    // Perform carrier sense for maxCarrierSenseTime
	while(time_before(jiffies, endjiffistime))
	{
		ret = sx127x_read_rssi(sx127x_ptr, freq, &rssi);

        if(rssi > rssiThresh)
        {
            ret = 1;
            break;
        }
	}

	//I think we need to receive, not send now
	//if(ret)
	//{
	//	sx127x_start_rx(sx127x_ptr);
	//}
	//else
	//{
		//we can send data at the moment
	//}
	
    return ret;
}

static int sx127x_start_cad(struct sx127x *sx127x_ptr)
{
    u8 reg = 0;
    int ret = 0;
    u32 freq = 0;
	u32 bandwidth = 0;
	u32 datarate = 0;
	u32 coderate = 0;
	u16 preambleLen = 0;
    bool crcOn = true;
    bool fixLen = false;
    bool iqInverted = false;
    //bool rxContinuou = true;
    bool freqHopOn = false;
    u16 symbTimeout = 5;
    u8 payloadLen = 0;
    u8 hopPeriod = 0;
    u8 LowDatarateOptimize = 0;
    
    struct spi_device *spi = to_spi_device(sx127x_ptr->dev);

	freq = sx127x_ptr->cfg.LoRa.rChannel;
	bandwidth = sx127x_ptr->cfg.LoRa.rBandwidth;
	datarate = sx127x_ptr->cfg.LoRa.rDatarate;
	coderate = sx127x_ptr->cfg.LoRa.rCoderate;
	preambleLen = sx127x_ptr->cfg.LoRa.PreambleLen;
	
    ret = sx127x_set_freq(sx127x_ptr, freq);
    if(ret < 0)
    {
        goto error;
    }
    
    
    if( ( ( bandwidth == 7 ) && ( ( datarate == 11 ) || ( datarate == 12 ) ) ) ||
        ( ( bandwidth == 8 ) && ( datarate == 12 ) ) )
    {
        LowDatarateOptimize = 0x01;
    }
    else
    {
        LowDatarateOptimize = 0x00;
    }


    sx127x_reg_read(spi, REG_LR_MODEMCONFIG1, &reg);
    sx127x_reg_write(spi, REG_LR_MODEMCONFIG1,
                 ( reg &
                   RFLR_MODEMCONFIG1_BW_MASK &
                   RFLR_MODEMCONFIG1_CODINGRATE_MASK &
                   RFLR_MODEMCONFIG1_IMPLICITHEADER_MASK ) |
                   ( bandwidth << 4 ) | ( coderate << 1 ) |
                   fixLen );

    sx127x_reg_read(spi, REG_LR_MODEMCONFIG2, &reg);
    sx127x_reg_write(spi, REG_LR_MODEMCONFIG2,
                 ( reg &
                   RFLR_MODEMCONFIG2_SF_MASK &
                   RFLR_MODEMCONFIG2_RXPAYLOADCRC_MASK &
                   RFLR_MODEMCONFIG2_SYMBTIMEOUTMSB_MASK ) |
                   ( datarate << 4 ) | ( crcOn << 2 ) |
                   ( ( symbTimeout >> 8 ) & ~RFLR_MODEMCONFIG2_SYMBTIMEOUTMSB_MASK ) );

    sx127x_reg_read(spi, REG_LR_MODEMCONFIG3, &reg);
    sx127x_reg_write(spi, REG_LR_MODEMCONFIG3,
                 ( reg &
                   RFLR_MODEMCONFIG3_LOWDATARATEOPTIMIZE_MASK ) |
                   ( LowDatarateOptimize << 3 ) );

    sx127x_reg_write(spi, REG_LR_SYMBTIMEOUTLSB, ( u8 )( symbTimeout & 0xFF ) );

    sx127x_reg_write(spi, REG_LR_PREAMBLEMSB, ( u8 )( ( preambleLen >> 8 ) & 0xFF ) );
    sx127x_reg_write(spi, REG_LR_PREAMBLELSB, ( u8 )( preambleLen & 0xFF ) );

    if( fixLen == true )
    {
        sx127x_reg_write(spi, REG_LR_PAYLOADLENGTH, payloadLen );
    }

    if(freqHopOn == true )
    {
        sx127x_reg_read(spi, REG_LR_PLLHOP, &reg);
        sx127x_reg_write(spi, REG_LR_PLLHOP, ( reg & RFLR_PLLHOP_FASTHOP_MASK ) | RFLR_PLLHOP_FASTHOP_ON );
        sx127x_reg_write(spi, REG_LR_HOPPERIOD, hopPeriod );
    }

    if( ( bandwidth == 9 ) && ( freq > RF_MID_BAND_THRESH ) )
    {
        // ERRATA 2.1 - Sensitivity Optimization with a 500 kHz Bandwidth
        sx127x_reg_write(spi, REG_LR_TEST36, 0x02);
        sx127x_reg_write(spi, REG_LR_TEST3A, 0x64);
    }
    else if( bandwidth == 9 )
    {
        // ERRATA 2.1 - Sensitivity Optimization with a 500 kHz Bandwidth
        sx127x_reg_write(spi, REG_LR_TEST36, 0x02);
        sx127x_reg_write(spi, REG_LR_TEST3A, 0x7F);
    }
    else
    {
        // ERRATA 2.1 - Sensitivity Optimization with a 500 kHz Bandwidth
        sx127x_reg_write(spi, REG_LR_TEST36, 0x03);
    }

    if( datarate == 6 )
    {
        sx127x_reg_read(spi, REG_LR_DETECTOPTIMIZE, &reg);
        sx127x_reg_write(spi, REG_LR_DETECTOPTIMIZE,
                     (reg  &
                       RFLR_DETECTIONOPTIMIZE_MASK ) |
                       RFLR_DETECTIONOPTIMIZE_SF6 );
        sx127x_reg_write(spi, REG_LR_DETECTIONTHRESHOLD,
                     RFLR_DETECTIONTHRESH_SF6 );
    }
    else
    {
        sx127x_reg_read(spi, REG_LR_DETECTOPTIMIZE, &reg);
        sx127x_reg_write(spi, REG_LR_DETECTOPTIMIZE,
                     ( reg &
                     RFLR_DETECTIONOPTIMIZE_MASK ) |
                     RFLR_DETECTIONOPTIMIZE_SF7_TO_SF12 );
        sx127x_reg_write(spi, REG_LR_DETECTIONTHRESHOLD,
                     RFLR_DETECTIONTHRESH_SF7_TO_SF12 );
    }

    if(iqInverted == true)
    {
        sx127x_reg_read(spi, REG_LR_INVERTIQ, &reg) ;
        
        sx127x_reg_write(spi, REG_LR_INVERTIQ, ((reg & RFLR_INVERTIQ_TX_MASK & RFLR_INVERTIQ_RX_MASK) |
                                                RFLR_INVERTIQ_RX_ON | RFLR_INVERTIQ_TX_OFF));
        sx127x_reg_write(spi, REG_LR_INVERTIQ2, RFLR_INVERTIQ2_ON);
    }
    else
    {
        sx127x_reg_read(spi, REG_LR_INVERTIQ, &reg) ;
        
        sx127x_reg_write(spi, REG_LR_INVERTIQ, ((reg & RFLR_INVERTIQ_TX_MASK & RFLR_INVERTIQ_RX_MASK) | 
                                            RFLR_INVERTIQ_RX_OFF | RFLR_INVERTIQ_TX_OFF));
        sx127x_reg_write(spi, REG_LR_INVERTIQ2, RFLR_INVERTIQ2_OFF);
    }

    // ERRATA 2.3 - Receiver Spurious Reception of a LoRa Signal
    if(bandwidth < 9)
    {
        sx127x_reg_read(spi, REG_LR_DETECTOPTIMIZE, &reg);
        sx127x_reg_write(spi, REG_LR_DETECTOPTIMIZE, reg & 0x7F);
        sx127x_reg_write(spi, REG_LR_TEST30, 0x00);
        switch(bandwidth)
        {
        case 0: // 7.8 kHz
            sx127x_reg_write(spi, REG_LR_TEST2F, 0x48);
            sx127x_set_freq(sx127x_ptr, freq + 7810);
            break;
        case 1: // 10.4 kHz
            sx127x_reg_write(spi, REG_LR_TEST2F, 0x44);
            sx127x_set_freq(sx127x_ptr, freq + 10420 );
            break;
        case 2: // 15.6 kHz
            sx127x_reg_write(spi, REG_LR_TEST2F, 0x44);
            sx127x_set_freq(sx127x_ptr, freq + 15620 );
            break;
        case 3: // 20.8 kHz
            sx127x_reg_write(spi, REG_LR_TEST2F, 0x44);
            sx127x_set_freq(sx127x_ptr, freq + 20830 );
            break;
        case 4: // 31.2 kHz
            sx127x_reg_write(spi, REG_LR_TEST2F, 0x44);
            sx127x_set_freq(sx127x_ptr, freq + 31250);
            break;
        case 5: // 41.4 kHz
            sx127x_reg_write(spi, REG_LR_TEST2F, 0x44);
            sx127x_set_freq(sx127x_ptr, freq + 41670 );
            break;
        case 6: // 62.5 kHz
            sx127x_reg_write(spi, REG_LR_TEST2F, 0x40);
            break;
        case 7: // 125 kHz
            sx127x_reg_write(spi, REG_LR_TEST2F, 0x40);
            break;
        case 8: // 250 kHz
            sx127x_reg_write(spi,  REG_LR_TEST2F, 0x40);
            break;
        }
    }
    else
    {
        sx127x_reg_read(spi, REG_LR_DETECTOPTIMIZE, &reg);
        sx127x_reg_write(spi, REG_LR_DETECTOPTIMIZE, reg | 0x80 );
    }

    sx127x_reg_write(spi, REG_LR_IRQFLAGSMASK, RFLR_IRQFLAGS_RXTIMEOUT |
                                RFLR_IRQFLAGS_RXDONE |
                                RFLR_IRQFLAGS_PAYLOADCRCERROR |
                                RFLR_IRQFLAGS_VALIDHEADER |
                                RFLR_IRQFLAGS_TXDONE |
                                //RFLR_IRQFLAGS_CADDONE |
                                RFLR_IRQFLAGS_FHSSCHANGEDCHANNEL // |
                                //RFLR_IRQFLAGS_CADDETECTED
                                );

    // DIO3=CADDone
    sx127x_reg_read(spi, REG_DIOMAPPING1, &reg);
    sx127x_reg_write(spi, REG_DIOMAPPING1, (reg & RFLR_DIOMAPPING1_DIO3_MASK) | RFLR_DIOMAPPING1_DIO3_00);

    //SX1276.Settings.State = RF_CAD;
    sx127x_set_opmode(sx127x_ptr, RFLR_OPMODE_CAD );

error:	
	
    return ret;
}


int sx127x_start_rx(struct sx127x *sx127x_ptr)
{
    int ret = 0;

    ret = sx127x_set_rxconfig(sx127x_ptr, sx127x_ptr->cfg.LoRa.rChannel, sx127x_ptr->cfg.LoRa.rBandwidth, 
                                          sx127x_ptr->cfg.LoRa.rDatarate, sx127x_ptr->cfg.LoRa.rCoderate, 
                                          sx127x_ptr->cfg.LoRa.PreambleLen);
    if(ret < 0)
    {
        goto error;
    }

    ret = sx127x_setrx(sx127x_ptr);
    if(ret < 0)
    {
        goto error;
    }
    
error:

    return ret;
}


static int sx127x_indexofstring(const char* str, const char** options, unsigned noptions){
    int i;
    for (i = 0; i < noptions; i++) {
        if (sysfs_streq(str, options[i])) {
            return i;
        }
    }
    return -1;
}

static ssize_t sx127x_modulation_show(struct device *child, struct device_attribute *attr, char *buf)
{
    struct sx127x *data = dev_get_drvdata(child);
    
    RadioModems_t mod;
    int ret;
    mutex_lock(&data->mutex);
    
    ret = sx127x_get_modem(data, &mod);

    ret = sprintf(buf, "%s\n", modstr[mod]);
    
    mutex_unlock(&data->mutex);
    return ret;

}

static ssize_t sx127x_modulation_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
{
    struct sx127x *data = dev_get_drvdata(dev);
	
    int idx = sx127x_indexofstring(buf, modstr, ARRAY_SIZE(modstr));
    if(idx == -1)
	{
        dev_warn(dev, "invalid modulation type, please enter fsk or lora\n");
        goto out;
    }
    mutex_lock(&data->mutex);
    data->cfg.Modem = idx;
    mutex_unlock(&data->mutex);
	
out:
    return count;
}

static DEVICE_ATTR(modulation, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH, sx127x_modulation_show, sx127x_modulation_store);

static ssize_t sx127x_opmode_show(struct device *dev, struct device_attribute *attr, char *buf)
{
    int ret = 0;
    struct sx127x *data = dev_get_drvdata(dev);
    u8 opmode;
    
	mutex_lock(&data->mutex);
    ret = sx127x_get_opmode(data, &opmode);
    if(ret < 0)
    {
        goto error;
    }
    
    if(opmode > 4){
        ret = sprintf(buf, "%s\n", opmodestr[1]);
    }
    else {
        ret =sprintf(buf, "%s\n", opmodestr[0]);
    }
	
	mutex_unlock(&data->mutex);
error:
    
    return ret;
}
#if 0
static int sx127x_toggletxrxen(struct sx127x *data, bool tx)
{
    //if(data->gpio_txen){
        //if(tx){
        //    dev_warn(data->dev, "enabling tx\n");
        //}
        //gpiod_set_value(data->gpio_txen, tx);
    //}
    //if(data->gpio_rxen){
    //    if(!tx){
    //        dev_warn(data->dev, "enabling rx\n");
    //    }
        //gpiod_set_value(data->gpio_rxen, !tx);
    //}
    return 0;
}

static int sx127x_setsyncword(struct sx127x *data, u8 syncword)
{
    int ret = 0;
    
    dev_warn(data->dev, "setting syncword to %d\n", syncword);
    
    return ret;
}

static int sx127x_setinvertiq(struct sx127x *data, bool invert)
{
    int ret = 0;
    
    dev_warn(data->dev, "setting invertiq to %d\n", invert);
    
    return ret;
}

static int sx127x_setcrc(struct sx127x *data, bool crc)
{
    int ret = 0;
    
    dev_warn(data->dev, "setting crc to %d\n", crc);
    
    return ret;
}
#endif
static ssize_t sx127x_opmode_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
{
    struct sx127x *data = dev_get_drvdata(dev);
    int idx;
    u8 mode;

    idx = sx127x_indexofstring(buf, opmodestr, ARRAY_SIZE(opmodestr));
    if(idx == -1){
        dev_err(dev, "invalid opmode\n");
        goto out;
    }
    mutex_lock(&data->mutex);
    mode = idx;
    sx127x_set_opmode(data, mode);
    mutex_unlock(&data->mutex);
out:
    return count;
}

static DEVICE_ATTR(opmode, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH, sx127x_opmode_show, sx127x_opmode_store);

static ssize_t sx127x_carrierfrequency_show(struct device *dev, struct device_attribute *attr, char *buf)
{
    u32 txfreq = 0;
	u32 rxfreq = 0;
	struct sx127x *data = dev_get_drvdata(dev);
	
	txfreq = data->cfg.LoRa.tChannel;
	rxfreq = data->cfg.LoRa.rChannel;
	
    return sprintf(buf, "txfreq:%uHz rxfreq:%uHz\n", txfreq, rxfreq);
}

static ssize_t sx127x_carrierfrequency_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
{
    u32 freq;

    if(kstrtou32(buf, 10, &freq)){
        goto out;
    }

out:
    return count;
}

static DEVICE_ATTR(carrierfrequency, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH, sx127x_carrierfrequency_show, sx127x_carrierfrequency_store);

static ssize_t sx127x_rssi_show(struct device *child, struct device_attribute *attr, char *buf)
{
    return sprintf(buf, "%d\n", 0);
}

static DEVICE_ATTR(rssi, S_IRUSR | S_IRGRP | S_IROTH, sx127x_rssi_show, NULL);

static ssize_t sx127x_sf_show(struct device *dev, struct device_attribute *attr, char *buf)
{
    int sf = 0;
    

    return sprintf(buf, "%d\n", sf);
}
#if 0
static int sx127x_setsf(struct sx127x *data, unsigned sf){
    int ret = 0;
    
    dev_info(data->dev, "setting spreading factor to %u\n", sf);
    
    return ret;
}
#endif
static ssize_t sx127x_sf_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
{
    int sf;
    if(kstrtoint(buf, 10, &sf)){
        goto out;
    }

out:
    return count;
}

static DEVICE_ATTR(sf, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH, sx127x_sf_show, sx127x_sf_store);

static ssize_t sx127x_bw_show(struct device *dev, struct device_attribute *attr, char *buf)
{
    int ret = 0;

    return ret;
}

static ssize_t sx127x_bw_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count){
    //struct sx127x *data = dev_get_drvdata(dev);
    return count;
}

static DEVICE_ATTR(bw, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH, sx127x_bw_show, sx127x_bw_store);

//static char* crmap[] = { NULL, "4/5", "4/6", "4/7", "4/8" };

static ssize_t sx127x_codingrate_show(struct device *dev, struct device_attribute *attr, char *buf)
{
    int ret = 0;
    
    return ret;
}

static ssize_t sx127x_codingrate_store(struct device *dev, struct device_attribute *attr,
             const char *buf, size_t count){
    //struct sx127x *data = dev_get_drvdata(dev);
    return count;
}

static DEVICE_ATTR(codingrate, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH, sx127x_codingrate_show, sx127x_codingrate_store);

static ssize_t sx127x_implicitheadermodeon_show(struct device *dev, struct device_attribute *attr, char *buf)
{
    
    return sprintf(buf, "%d\n", 0);
}

int SX127XSetImplicitHeader(struct sx127x *data, unsigned *implicitheader)
{
    int ret = 0;

    return ret;
}
static ssize_t sx127x_implicitheadermodeon_store(struct device *dev, struct device_attribute *attr,
             const char *buf, size_t count){
    //struct sx127x *data = dev_get_drvdata(dev);
    return count;
}

static DEVICE_ATTR(implicitheadermodeon, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH, sx127x_implicitheadermodeon_show, sx127x_implicitheadermodeon_store);


static ssize_t sx127x_paoutput_show(struct device *dev, struct device_attribute *attr, char *buf)
{
    int idx = 0;
	struct sx127x *data = dev_get_drvdata(dev);
	
	idx = data->cfg.pa;
	
    return sprintf(buf, "%s\n", paoutput[idx]);
}


#if 0
static int sx127x_setpaoutput(struct sx127x *data, enum sx127x_pa pa)
{
    int ret = 0;

    return ret;
}
#endif

static ssize_t sx127x_paoutput_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
{
    //TODO this needs to take into account non-default values for the "padac".
    struct sx127x *data = dev_get_drvdata(dev);
    int idx = sx127x_indexofstring(buf, paoutput, ARRAY_SIZE(paoutput));
	
    if(idx == -1)
        goto out;

	mutex_lock(&data->mutex);
	data->cfg.pa = idx;
	mutex_unlock(&data->mutex);
out:
    return count;
}

static DEVICE_ATTR(paoutput, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH, sx127x_paoutput_show, sx127x_paoutput_store);


static ssize_t sx127x_outputpower_show(struct device *dev, struct device_attribute *attr, char *buf)
{
    struct sx127x *data = dev_get_drvdata(dev);
    int outputpower = data->cfg.LoRa.Power;

    return sprintf(buf, "%d\n", outputpower);
}


static ssize_t sx127x_outputpower_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
{
	int power = 0;
    struct sx127x *data = dev_get_drvdata(dev);
	
	if(kstrtou32(buf, 10, &power))
	{
		goto error;
	}
	
	data->cfg.LoRa.Power = power;
error:
	
    return count;
}

static DEVICE_ATTR(outputpower, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH,
        sx127x_outputpower_show, sx127x_outputpower_store);

static int drv_open(struct inode *inode, struct file *file)
{
    int ret = 0;
    struct sx127x *data;
    int status = -ENXIO;
    mutex_lock(&device_list_lock);

    list_for_each_entry(data, &device_list, device_entry) {
        if (data->devt == inode->i_rdev) {
            status = 0;
            break;
        }
    }

    if(status){
        pr_debug("sx127x: nothing for minor %d\n", iminor(inode));
        goto err_notfound;
    }

    mutex_lock(&data->mutex);
    if(!atomic_dec_and_test(&data->opened)) 
    {
        pr_debug("sx127x: already open\n");
        status = -EBUSY;
        goto err_open1;
    }

    if(data->open){
        pr_debug("sx127x: already open\n");
        status = -EBUSY;
        goto err_open;
    }
    data->open = 1;

    mutex_unlock(&data->mutex);
    

    ret = sx127x_init(data);
    
    mutex_unlock(&device_list_lock);

    file->private_data = data;
    return 0;

err_open:
    atomic_inc(&data->opened);
err_open1:
    mutex_unlock(&data->mutex);
err_notfound:
    mutex_unlock(&device_list_lock);
    return status;
}

static ssize_t drv_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos)
{
    struct sx127x *data = filp->private_data;
    unsigned copied;
    ssize_t ret = 0;
    wait_event_interruptible(data->readwq, kfifo_len(&data->out));
    ret = kfifo_to_user(&data->out, buf, count, &copied);
    if(!ret && copied > 0){
        ret = copied;
    }
    return ret;
}

static ssize_t drv_write(struct file *filp, const char __user *buf, size_t count, loff_t *f_pos)
{
    int ret = 0;
    struct sx127x *data = filp->private_data;
    struct spi_device *spi = to_spi_device(data->dev);
    
    size_t packetsz, offset, maxpkt = 256;
    u8 kbuf[256] = {0};
    //dev_info(data->dev, "char device write; %d\n", count);
    //config first
    sx127x_set_txconfig(data, data->cfg.LoRa.tChannel, data->cfg.LoRa.Power, data->cfg.LoRa.tBandwidth, 
                              data->cfg.LoRa.tDatarate, data->cfg.LoRa.tCoderate, data->cfg.LoRa.PreambleLen);
    
    for(offset = 0; offset < count; offset += maxpkt){
        packetsz = min((count - offset), maxpkt);
        mutex_lock(&data->mutex);
        ret = copy_from_user(kbuf, buf + offset, packetsz);
        if(ret < 0)
        {
            goto error;
        }

        sx127x_set_opmode(data, SX127X_OPMODE_STANDBY);
    
        sx127x_fifo_writepkt(spi, kbuf, packetsz);
        
        data->transmitted = 0;
        
        sx127x_set_opmode(data, SX127X_OPMODE_TX);
        
        mutex_unlock(&data->mutex);
        wait_event_interruptible_timeout(data->writewq, data->transmitted, msecs_to_jiffies(data->cfg.LoRa.TxTimeout));

        if(!data->transmitted)
        {
            ret = -ETIMEDOUT;
            goto error;
        }
    }

    //swicth rx mode
    //mutex_lock(&data->mutex);
    //sx127x_start_rx(data);
    //mutex_unlock(&data->mutex);

    return count;

error:

    //swicth rx mode
    //mutex_lock(&data->mutex);
    //sx127x_start_rx(data);
    //mutex_unlock(&data->mutex);
    
    return ret;
}

static int drv_release(struct inode *inode, struct file *filp)
{
    struct sx127x *data = filp->private_data;
    mutex_lock(&data->mutex);
    sx127x_irq_deinit(data);
     
    atomic_inc(&data->opened);
    sx127x_set_opmode(data, SX127X_OPMODE_STANDBY);
    data->open = 0;
    kfifo_reset(&data->out);
    mutex_unlock(&data->mutex);
    return 0;
}

static long drv_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
{
    struct sx127x *data = filp->private_data;
    int ret = 0;
    
    
    switch(cmd){
        case SET_MODEM:
        {
            u8 modem = (u8)arg;        
            mutex_lock(&data->mutex);
            switch(modem)
            {
            case MODEM_FSK_M:
                ret = sx127x_set_modem(data, MODEM_FSK);
                if(ret < 0)
                {
                    mutex_unlock(&data->mutex);
                    goto error;
                }
                data->cfg.Modem = MODEM_FSK;
                ret = 0;
                break;
            case MODEM_LORA_M:
                ret = sx127x_set_modem(data, MODEM_LORA);
                if(ret < 0)
                {
                    mutex_unlock(&data->mutex);
                    goto error;
                }
                data->cfg.Modem = MODEM_FSK;
                ret = 0;
                break;
            default:
                ret = -EINVAL;
                break;
            }
            mutex_unlock(&data->mutex);
            break;
        }
        case SET_TXFREQ:
        {
            u32 freq = (u32)arg;
            mutex_lock(&data->mutex);
            
            if((freq < SX1278_MIN_FREQ) || (freq > SX1278_MAX_FREQ))
            {
                ret = -EINVAL;
            }else{
                data->cfg.LoRa.tChannel = freq;
                ret = 0;
            }
            
            mutex_unlock(&data->mutex);
            break;
        }
        case SET_RXFREQ:
        {
            u32 freq = (u32)arg;
            mutex_lock(&data->mutex);
            
            if((freq < SX1278_MIN_FREQ) || (freq > SX1278_MAX_FREQ))
            {
                ret = -EINVAL;
            }else{
                data->cfg.LoRa.rChannel = freq;
                ret = 0;
            }
            
            mutex_unlock(&data->mutex);
            break;
        }
        case SET_TXBW:
        {
            u8 bandwidth = (u8)arg;
            u32 freq = data->cfg.LoRa.tChannel;
            mutex_lock(&data->mutex);
            if(bandwidth > BW_500KHZ)
            {
                ret = -EINVAL;
                mutex_unlock(&data->mutex);
                goto error;
                
            }

            if((freq <= 169000000) && ((bandwidth == BW_250KHZ) | (bandwidth == BW_500KHZ)))
            {
                ret = -EINVAL;
                mutex_unlock(&data->mutex);
                goto error;
            }

            data->cfg.LoRa.tBandwidth = bandwidth;
            ret = 0;
            mutex_unlock(&data->mutex);
            break;
        }
        case SET_RXBW:
        {
            u8 bandwidth = (u8)arg;
            u32 freq = data->cfg.LoRa.tChannel;
            mutex_lock(&data->mutex);
            if(bandwidth > BW_500KHZ)
            {
                ret = -EINVAL;
                mutex_unlock(&data->mutex);
                goto error;
                
            }

            if((freq <= 169000000) && ((bandwidth == BW_250KHZ) | (bandwidth == BW_500KHZ)))
            {
                ret = -EINVAL;
                mutex_unlock(&data->mutex);
                goto error;
            }

            data->cfg.LoRa.rBandwidth = bandwidth;

            ret = 0;
            mutex_unlock(&data->mutex);
            break;
        }
        case SET_TXSF:
        {
            u8 sf = (u8)arg;
            
            mutex_lock(&data->mutex);
            
            if((sf < SF_64_CHIPS_SYMBOL) && (sf > SF_4096_CHIPS_SYMBOL))
            {
                ret = -EINVAL;
            }else{
                data->cfg.LoRa.tDatarate = sf;
                ret = 0;
            }
            
            mutex_unlock(&data->mutex);
            break;
        }
        case SET_RXSF:
        {
            u8 sf = (u8)arg;
            
            mutex_lock(&data->mutex);
            
            if((sf < SF_64_CHIPS_SYMBOL) && (sf > SF_4096_CHIPS_SYMBOL))
            {
                ret = -EINVAL;
            }else{
                data->cfg.LoRa.rDatarate = sf;
                ret = 0;
            }
            
            mutex_unlock(&data->mutex);
            break;
        }
        case SET_TXCR:
        {
            u8 codingrate = (u8)arg;
            
            mutex_lock(&data->mutex);
            
            if((codingrate < CR_4_5) && (codingrate > CR_4_8))
            {
                ret = -EINVAL;
            }else{
                data->cfg.LoRa.tCoderate= codingrate;
                ret = 0;
            }
            
            mutex_unlock(&data->mutex);
            break;
        }
        case SET_RXCR:
        {
            u8 codingrate = (u8)arg;
            
            mutex_lock(&data->mutex);
            
            if((codingrate < CR_4_5) && (codingrate > CR_4_8))
            {
                ret = -EINVAL;
            }else{
                data->cfg.LoRa.rCoderate = codingrate;
                ret = 0;
            }
            
            mutex_unlock(&data->mutex);
            
            break;
            
        }
        case SET_PAOUTPUT:
        {
            u8 paoutput = (u8)arg;

            mutex_lock(&data->mutex);

            switch(paoutput)
            {
            case PA_RFO:
            {
                data->cfg.pa = SX127X_PA_RFO;
                break;
            }
            case PA_BOOST:
            {
                data->cfg.pa = SX127X_PA_PABOOST;
                break;
            }
            default:
            {
                ret = -EINVAL;
                break;
            }
            }

            mutex_unlock(&data->mutex);
            break;
        }
        case SET_TXPOWER:
        {
            int power = (int)arg;
            enum sx127x_pa pa = data->cfg.pa;

            mutex_lock(&data->mutex);
            switch(pa)
            {
            case SX127X_PA_RFO:
            {
                if((power < -1) || (power > 14))
                {
                    ret = -EINVAL;
                }else{
                    data->cfg.LoRa.Power = power;
                    ret = 0;
                }
                break;
            }
            case SX127X_PA_PABOOST:
            {
                if((power < 2) || (power > 20))
                {
                    ret = -EINVAL;
                }else{
                    data->cfg.LoRa.Power = power;
                    ret = 0;
                }
                
                break;
            }
            default:
            {
                ret = -EINVAL;
                break;
            }
            }

            mutex_unlock(&data->mutex);
            break;
        }
        case SET_FDEV:
        {
            ret = 0;
            break;
        }
        case SET_PREAMBLELEN:
        {
            u16 preamblelen = (u16)arg;

            mutex_lock(&data->mutex);
            data->cfg.LoRa.PreambleLen = preamblelen;
            ret = 0;
            mutex_unlock(&data->mutex);
            break;
        }
        case SET_OPMODE:
        {
            u8 opmode = (u8)arg;
            mutex_lock(&data->mutex);
            switch(opmode)
            {
            case OPMODE_SLEEP:
            {
                ret = sx127x_set_opmode(data, RF_OPMODE_SLEEP);
                break;
            }
            case OPMODE_STANDBY:
            {
                ret = sx127x_set_opmode(data, RF_OPMODE_STANDBY);
                break;
            }
            case OPMODE_FSTX:
            {
                ret = sx127x_set_opmode(data, RF_OPMODE_SYNTHESIZER_TX);
                break;
            }
            case OPMODE_TX:
            {
                ret = sx127x_set_opmode(data, RF_OPMODE_TRANSMITTER);
                break;
            }
            case OPMODE_FSRX:
            {
                ret = sx127x_set_opmode(data, RF_OPMODE_SYNTHESIZER_RX);
                break;
            }
            case OPMODE_RXCONTINUOS:
            {
                ret = sx127x_set_opmode(data, RF_OPMODE_RECEIVER);
                break;
            }
            case OPMODE_RXSINGLE:
            {
                ret = sx127x_set_opmode(data, OPMODE_RXSINGLE);
                break;
            }
            case OPMODE_CAD:
            {
                ret = sx127x_set_opmode(data, OPMODE_CAD);
                break;
            }
            default:
            {
                ret = -EINVAL;
                break;
            }
            }
            mutex_unlock(&data->mutex);
            break;
        }
        case SET_TXTIMEOUT:
        {
            int timeout = (int)arg;
            mutex_lock(&data->mutex);
            data->cfg.LoRa.TxTimeout = timeout;
            mutex_unlock(&data->mutex);
            break;
        }
        case SET_RECVDATA:
        {
            //u8 enable = (u8)arg;
            mutex_lock(&data->mutex);
            //if(enable)
            ret = sx127x_start_rx(data);
            //else
                //may be we can stop it, just an ideal
#if 0			
			printk(KERN_ERR "TxFreq:%d\n", 	data->cfg.LoRa.tChannel);
			printk(KERN_ERR "RxFreq:%d\n", 	data->cfg.LoRa.rChannel);
			printk(KERN_ERR "TxBW:%d\n", 	data->cfg.LoRa.tBandwidth);
			printk(KERN_ERR "RxBW:%d\n", 	data->cfg.LoRa.rBandwidth);
			printk(KERN_ERR "TxSF:%d\n", 	data->cfg.LoRa.tDatarate);
			printk(KERN_ERR "RxSF:%d\n", 	data->cfg.LoRa.rDatarate);
			printk(KERN_ERR "TxCR:%d\n", 	data->cfg.LoRa.tCoderate);
			printk(KERN_ERR "RxCR:%d\n", 	data->cfg.LoRa.rCoderate);
			printk(KERN_ERR "Power:%d\n", 	data->cfg.LoRa.Power);
			printk(KERN_ERR "Preamble len:%d\n", data->cfg.LoRa.PreambleLen);
			printk(KERN_ERR "paoutput:%d\n", data->cfg.pa);
			printk(KERN_ERR "TxTimeout:%d\n", data->cfg.LoRa.TxTimeout);
#endif			
            mutex_unlock(&data->mutex);
            break;
        }
        case START_CAD:
        {
			//I think we need set freq first
			u8 cadback = 0;
			
			mutex_lock(&data->mutex);
            sx127x_start_cad(data);

            data->caddone = 0;
            //timeout 100ms
            wait_event_interruptible_timeout(data->cadwq, data->caddone, msecs_to_jiffies(100));
            switch(data->caddone)
            {
            case 0:
			{
				//timeout;
				//ret = __put_user(cadback, (u8 __user *)arg);
				
				ret = -ETIMEDOUT;
				
				break;
        	}
			case 1:
			{
				//detected nothing
				//u8 snr = 0;
				//u8 rssi = 0;
				//u32 freq = data->cfg.LoRa.tChannel;
				//sx127x_read_snr_rssi(data, freq, &snr, &rssi);
				
				cadback =  CAD_DETECTED;
				
				ret = __put_user(cadback, (u8 __user *)arg);
				break;
			}
			case 2:
			{
				//detected 
				//u8 snr = 0;
				//u8 rssi = 0;
				//u32 freq = data->cfg.LoRa.tChannel;
				//sx127x_read_snr_rssi(data, freq, &snr, &rssi);
				
				//cadback = (snr << 16) | (rssi << 8) | CAD_DETECTED;
				cadback = CAD_NODETECTED;
				
				ret = __put_user(cadback, (u8 __user *)arg);
				break;
			}
			default:
			{
				//inval 
				
				ret = -EINVAL;
				
				break;
			}
			}
			
			//if(cadback)
			//{
				//channel is not free, I think we can not send data 
				//sx127x_start_rx(data);
			//}
			//else
			//{
				//channel is free,I think we can send data
			//}
            mutex_unlock(&data->mutex);
            break;
        }
        case START_RSSI:
		{
			u8 flag = 0;
			u32 freq = data->cfg.LoRa.rChannel;
			s16 rssiThresh = 0;
			
			__get_user(rssiThresh, (u8 __user *)arg);
			mutex_lock(&data->mutex);
			
			ret = sx127x_detect_chan_rssi(data, freq, rssiThresh, 100);
			
			if(ret == 0)
			{
				flag = 1;
				__put_user(flag, (u8 __user *)arg);
			}else if(ret == 1){
				flag = 0;
				__put_user(flag, (u8 __user *)arg);
			}
			mutex_unlock(&data->mutex);
			break;
		}
        default:
            ret = -EINVAL;
            break;
    }
    
error:
    
    return ret;
}

static unsigned int drv_poll(struct file *file, poll_table *wait)  
{      
    unsigned int mask = 0;
    struct sx127x *sx127x_ptr = NULL;
	
    sx127x_ptr = file->private_data;   
  
    poll_wait(file, &sx127x_ptr->readwq, wait);        
     
    if(kfifo_len(&sx127x_ptr->out))     
    {
        mask |= POLLIN | POLLRDNORM;    
    }        
        
    return mask;    
}  


static struct file_operations drv_fops = {
        .open 			= drv_open,
        .read 			= drv_read,
        .write 			= drv_write,
        .release 		= drv_release,
        .unlocked_ioctl = drv_ioctl,
		.poll           = drv_poll,
};


static int sx127x_probe(struct spi_device *spi){
    int ret = 0;
    struct sx127x *data;
    u8 version;
    unsigned minor;

   // allocate all of the crap we need
    data = kmalloc(sizeof(*data), GFP_KERNEL);
    if(!data){
        DPRINTK("failed to allocate driver data\n");
        ret = -ENOMEM;
        goto err_allocdevdata;
    }

    data->open = 0;
    data->name = spi->modalias;
    //init the open flag
    atomic_set(&data->opened, 1);
    //INIT_WORK(&data->irq_work, sx127x_irq_work_handler);
    INIT_LIST_HEAD(&data->device_entry);
    init_waitqueue_head(&data->readwq);
    init_waitqueue_head(&data->writewq);
    mutex_init(&data->mutex);
    data->dev = &spi->dev;
    data->fosc = 32000000; //TODO use value from DT
    data->cfg.pa = SX127X_PA_PABOOST; // TODO use value from DT
    data->cfg.LoRa.tChannel = 470300000;
    data->cfg.LoRa.tBandwidth = 7;
    data->cfg.LoRa.tDatarate = 12;
    data->cfg.LoRa.tCoderate = 1;
    data->cfg.LoRa.Power = 14;
    
    data->cfg.LoRa.rChannel = 470300000;
    data->cfg.LoRa.rBandwidth = 7;
    data->cfg.LoRa.rDatarate = 12;
    data->cfg.LoRa.rCoderate = 1;

    data->cfg.LoRa.PreambleLen = 8;

    ret = kfifo_alloc(&data->out, PAGE_SIZE, GFP_KERNEL);
    if(ret){
        DPRINTK("failed to allocate out fifo\n");
        goto err_allocoutfifo;
    }
    
    ret = sx127x_parse_dt(&spi->dev, &data->plat_data);
    if(ret < 0)
    {
        goto err_resetgpio;
    }

    // get the rev from the chip and check it's what we expect
    sx127x_reg_read(spi, REG_LR_VERSION, &version);
    if(version != 0x12){
        dev_err(&spi->dev, "unknown chip version %x\n", version);
        ret = -EINVAL;
        goto err_chipid;
    }
    dev_warn(&spi->dev, "detected sx127x chip with version 0x%x\n",(unsigned) version);

    // create the frontend device and stash it in the spi device
    mutex_lock(&device_list_lock);
    minor = find_first_zero_bit(minors, DRV_MINOR);
    if (minor < DRV_MINOR) {
        data->devt = MKDEV(DRV_MAJOR, minor);
        data->chardev = device_create(drv_class, &spi->dev, data->devt, data, "%s%d", DRV_NAME, minor);
        if(IS_ERR(data->chardev)){
            dev_err(&spi->dev, "failed to create char device\n");
            ret = -ENOMEM;
            goto err_createdevice;
        }
        set_bit(minor, minors);
        list_add(&data->device_entry, &device_list);
    }
    mutex_unlock(&device_list_lock);
    spi_set_drvdata(spi, data);
    // setup sysfs nodes
    ret = device_create_file(data->chardev, &dev_attr_modulation);
    ret = device_create_file(data->chardev, &dev_attr_opmode);
    ret = device_create_file(data->chardev, &dev_attr_carrierfrequency);
    ret = device_create_file(data->chardev, &dev_attr_rssi);
    ret = device_create_file(data->chardev, &dev_attr_paoutput);
    ret = device_create_file(data->chardev, &dev_attr_outputpower);
    // these are LoRa specifc
    ret = device_create_file(data->chardev, &dev_attr_sf);
    ret = device_create_file(data->chardev, &dev_attr_bw);
    ret = device_create_file(data->chardev, &dev_attr_codingrate);
    ret = device_create_file(data->chardev, &dev_attr_implicitheadermodeon);

    return 0;

//err_sysfs:
//    device_destroy(devclass, data->devt);
err_createdevice:
    mutex_unlock(&device_list_lock);
//err_irq:
err_chipid:
err_resetgpio:
    kfifo_free(&data->out);
err_allocoutfifo:
    kfree(data);
err_allocdevdata:
    return ret;
}

static int sx127x_remove(struct spi_device *spi){
    struct sx127x *data = spi_get_drvdata(spi);

    device_remove_file(data->chardev, &dev_attr_modulation);
    device_remove_file(data->chardev, &dev_attr_opmode);
    device_remove_file(data->chardev, &dev_attr_carrierfrequency);
    device_remove_file(data->chardev, &dev_attr_rssi);
    device_remove_file(data->chardev, &dev_attr_paoutput);
    device_remove_file(data->chardev, &dev_attr_outputpower);

    device_remove_file(data->chardev, &dev_attr_sf);
    device_remove_file(data->chardev, &dev_attr_bw);
    device_remove_file(data->chardev, &dev_attr_codingrate);
    device_remove_file(data->chardev, &dev_attr_implicitheadermodeon);

    clear_bit(MINOR(data->devt), minors);

    device_destroy(drv_class, data->devt);
    
    kfifo_free(&data->out);
    kfree(data);

    return 0;
}

static const struct of_device_id sx127x_of_match[] = {
    {
        .compatible = "semtech, sx127x",
    },
    { },
};
MODULE_DEVICE_TABLE(of, sx127x_of_match);


static struct spi_driver sx127x_driver = {
    .probe        = sx127x_probe,
    .remove        = sx127x_remove,
    .driver = {
        .name    = SX127X_DRIVERNAME,
        .of_match_table = of_match_ptr(sx127x_of_match),
        .owner = THIS_MODULE,
    },
};

static int __init drv_init(void)
{
    int result = 0;
    //
    result = register_chrdev_region(drv_dev_num, DRV_MINOR, DRV_NAME);
    if (result)
    {
        goto ERR_EXIT;
    }
    
    //
    cdev_init(&drv_cdev, &drv_fops);
    drv_cdev.owner = THIS_MODULE;
    result = cdev_add(&drv_cdev, drv_dev_num, DRV_MINOR);
    if (result)   
    {        
        goto ERR_EXIT0;    
    }
    
    //    
    drv_class = class_create(THIS_MODULE, DRV_NAME);    
    if (drv_class == NULL) 
    {        
        result = -ENOMEM;        
        goto ERR_EXIT1;    
    }

    result = spi_register_driver(&sx127x_driver);
    if (result < 0)
    {
        goto ERR_EXIT2;
    }

    return result;
ERR_EXIT2:
    class_destroy(drv_class);
ERR_EXIT1:
    cdev_del(&drv_cdev);
ERR_EXIT0:
    unregister_chrdev_region(drv_dev_num, DRV_MINOR);
ERR_EXIT:    
    return result;
}
module_init(drv_init);

static void __exit drv_exit(void)
{
    spi_unregister_driver(&sx127x_driver);
    cdev_del(&drv_cdev);
    class_destroy(drv_class);
    drv_class = NULL;
    unregister_chrdev_region(drv_dev_num, DRV_MINOR);
}
module_exit(drv_exit);

MODULE_LICENSE("GPL");
