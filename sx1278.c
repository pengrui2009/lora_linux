/*****************************************************************************
 Copyright(C) Beijing Carsmart Technology Co., Ltd.
 All rights reserved.
 
 @file   : sx1278.c
 @brief  : the function of lora sx1278 module driver.
 @author : pengrui
 @history:
           2018-04-13    pengrui    Created file
           ...
******************************************************************************/
#include "sx1278.h"

static Sx1278_info_st sx1278_info;

/*!
 * \brief Radio hardware registers initialization definition
 *
 * \remark Can be automatically generated by the SX1276 GUI (not yet implemented)
 */
#define RADIO_INIT_REGISTERS_VALUE                \
{                                                 \
    { MODEM_FSK , REG_LNA                , 0x23 },\
    { MODEM_FSK , REG_RXCONFIG           , 0x1E },\
    { MODEM_FSK , REG_RSSICONFIG         , 0xD2 },\
    { MODEM_FSK , REG_AFCFEI             , 0x01 },\
    { MODEM_FSK , REG_PREAMBLEDETECT     , 0xAA },\
    { MODEM_FSK , REG_OSC                , 0x07 },\
    { MODEM_FSK , REG_SYNCCONFIG         , 0x12 },\
    { MODEM_FSK , REG_SYNCVALUE1         , 0xC1 },\
    { MODEM_FSK , REG_SYNCVALUE2         , 0x94 },\
    { MODEM_FSK , REG_SYNCVALUE3         , 0xC1 },\
    { MODEM_FSK , REG_PACKETCONFIG1      , 0xD8 },\
    { MODEM_FSK , REG_FIFOTHRESH         , 0x8F },\
    { MODEM_FSK , REG_IMAGECAL           , 0x02 },\
    { MODEM_FSK , REG_DIOMAPPING1        , 0x00 },\
    { MODEM_FSK , REG_DIOMAPPING2        , 0x30 },\
    { MODEM_LORA, REG_LR_PAYLOADMAXLENGTH, 0x40 },\
}

/*!
 * Radio hardware registers initialization
 *
 * \remark RADIO_INIT_REGISTERS_VALUE is defined in sx1278-board.h file
 */
const RadioRegisters_t RadioRegsInit[] = RADIO_INIT_REGISTERS_VALUE;





static int SX1278_Read_Reg(struct spi_device *spi_ptr, unsigned char addr, unsigned char *data_ptr)
{
    int result = 0;
    unsigned char reg = (addr & 0x7F);

    if((NULL == spi_ptr) || (NULL == data_ptr))
    {
        printk(KERN_ERR "%s %d error %d reading %x\n", __FUNCTION__, __LINE__, ret, addr);
        result = -ENOMEM;
        goto ERR_EXIT;
    }
    
    result = spi_write_then_read(spi_ptr, &reg, 1, data, 1);
    if (result < 0)
    {
        printk(KERN_ERR "%s %d error %d reading %x\n", __FUNCTION__, __LINE__, ret, addr);
        goto ERR_EXIT;
    }

ERR_EXIT:
    
    return result;
}

static int SX1278_Write_Reg(struct spi_device *spi_ptr, unsigned char addr, unsigned char data)
{
    int result = 0;
    unsigned char data_buf[2] = {0};
    data_buf[0] = (addr | 0x80);
    data_buf[1] = data;

    if(NULL == spi_ptr)
    {
        printk(KERN_ERR "%s %d error %d\n", __FUNCTION__, __LINE__, result);
        result = -ENOMEM;
        goto ERR_EXIT;
    }

    result = spi_write(spi_ptr, (void *)data_buf, 2);
    if (result < 0)
    {
        printk(KERN_ERR "%s %d write %d\n", __FUNCTION__, __LINE__, result);
        goto ERR_EXIT;
    }
    
    return result;
}

static int SX1278_Read_FIFO(struct spi_device *spi_ptr, uint8_t *data_ptr, uint32_t data_len)
{
    int result = 0;
    unsigned char reg = 0x00;
    struct spi_transfer t[2] = {0};
	struct spi_message m = {0};

    if((NULL == spi_ptr) || (NULL == data_ptr))
    {
        result = -ENOMEM;
        goto ERR_EXIT;
    }

    pdata = kzalloc((data_len + 1), GFP_KERNEL);
    if (!pdata) 
    {
		result = -ENOMEM;
		goto ERR_EXIT;
	}

    spi_message_init(&m);
    
	t[0].tx_buf = &reg;
	t[0].len = 1;

  	t[1].rx_buf = data_ptr;
	t[1].len = data_len ;
    
	spi_message_add_tail(&t, &m);

    spi_sync(spi, &m);

    *result += m.actual_length - 1;

ERR_EXIT:
    
    return result;
}

static int SX1278_Write_FIFO(struct spi_device *spi_ptr, uint8_t *data_ptr, uint8_t data_len)
{
    int result = 0;
    uint8_t *pdata = NULL;
    struct spi_transfer t = {0};
	struct spi_message m = {0};

    if((NULL == spi_ptr) || (NULL == data_ptr))
    {
        result = -ENOMEM;
        goto ERR_EXIT;
    }

    pdata = kzalloc((data_len + 1), GFP_KERNEL);
    if (!pdata) 
    {
		result = -ENOMEM;
		goto ERR_EXIT;
	}

    pdata[0] = 0x80;
    memcpy(&pdata[1], data_ptr, data_len);

    spi_message_init(&m);
    
	t.tx_buf = pdata;
	t.len = (data_len + 1);
    
	spi_message_add_tail(&t, &m);

    spi_sync(spi, &m);

    *result += m.actual_length - 1;
    
ERR_EXIT:

    if(pdata)
        kfree(pdata);
    
    return result;
}


/*!
 * Performs the Rx chain calibration for LF and HF bands
 * \remark Must be called just after the reset so all registers are at their
 *         default values
 */
static void RxChainCalibration(Sx1278_info_st_ptr sx1278_ptr)
{
    int result = 0;
    unsigned char val = 0, val1 = 0, val2 = 0;
    unsigned char regPaConfigInitVal = 0;
    unsigned int initialFreq = 0;
    

    if(NULL == sx1278_ptr)
    {
        result = -ENOMEM;
        goto ERR_EXIT;
    }

    // Save context
    result = SX1278_Read_Reg(sx1278_ptr->spi, REG_PACONFIG, &regPaConfigInitVal);
    if(result < 0)
    {
        goto ERR_EXIT;
    }

    result = SX1278_Read_Reg(sx1278_ptr->spi, REG_FRFMSB, &val);
    if(result < 0)
    {
        goto ERR_EXIT;
    }

    result = SX1278_Read_Reg(sx1278_ptr->spi, REG_FRFMID, &val1);
    if(result < 0)
    {
        goto ERR_EXIT;
    }

    result = SX1278_Read_Reg(sx1278_ptr->spi, REG_FRFLSB, &val2);
    if(result < 0)
    {
        goto ERR_EXIT;
    }
        
    initialFreq = (double)(((unsigned int)val << 16) |
                           ((unsigned int)val1 << 8) |
                           ((unsigned int)val2)) * (double)FREQ_STEP;

    // Cut the PA just in case, RFO output, power = -1 dBm
    result = SX1278_Write_Reg(sx1278_ptr->spi, REG_PACONFIG, 0x00);
    if(result < 0)
    {
        goto ERR_EXIT;
    }

    // Launch Rx chain calibration for LF band
    result = SX1278_Read_Reg(sx1278_ptr->spi, REG_IMAGECAL, &val);
    if(result < 0)
    {
        goto ERR_EXIT;
    }
    
    result = SX1278_Write_Reg(sx1278_ptr->spi, REG_IMAGECAL, ((val&RF_IMAGECAL_IMAGECAL_MASK)|RF_IMAGECAL_IMAGECAL_START));
    if(result < 0)
    {
        goto ERR_EXIT;
    }

    result = SX1278_Read_Reg(sx1278_ptr->spi, REG_IMAGECAL, &val);
    if(result < 0)
    {
        goto ERR_EXIT;
    }
    
    while((val&RF_IMAGECAL_IMAGECAL_RUNNING) == RF_IMAGECAL_IMAGECAL_RUNNING)
    {
        result = SX1278_Read_Reg(sx1278_ptr->spi, REG_IMAGECAL, &val);
        if(result < 0)
        {
            goto ERR_EXIT;
        }
    }

    // Sets a Frequency in HF band
    result = SX1278_SetChannel(sx1278_ptr, 868000000);
    if(result < 0)
    {
        goto ERR_EXIT;
    }

    result = SX1278_Read_Reg(sx1278_ptr->spi, REG_IMAGECAL, &val);
    if(result < 0)
    {
        goto ERR_EXIT;
    }

    // Launch Rx chain calibration for HF band
    result = SX1278_Write_Reg(sx1278_ptr->spi, REG_IMAGECAL, ((val&RF_IMAGECAL_IMAGECAL_MASK)|RF_IMAGECAL_IMAGECAL_START));
    if(result < 0)
    {
        goto ERR_EXIT;
    }

    result = SX1278_Read_Reg(sx1278_ptr->spi, REG_IMAGECAL, &val);
    if(result < 0)
    {
        goto ERR_EXIT;
    }
    
    while((val&RF_IMAGECAL_IMAGECAL_RUNNING) == RF_IMAGECAL_IMAGECAL_RUNNING)
    {
        result = SX1278_Read_Reg(sx1278_ptr->spi, REG_IMAGECAL, &val);
        if(result < 0)
        {
            goto ERR_EXIT;
        }
    }

    // Restore context
    result = SX1278_Write_Reg(sx1278_ptr->spi, REG_PACONFIG, regPaConfigInitVal);
    if(result < 0)
    {
        goto ERR_EXIT;
    }
    
    result = SX1278_SetChannel(sx1278_ptr, initialFreq);
    if(result < 0)
    {
        goto ERR_EXIT;
    }

ERR_EXIT:

    return result;
}

/*
 * Radio driver functions implementation
 */
int SX1278_IoInit(Sx1278_Gpio_st_ptr sx1278_gpio_ptr)
{
    int result = 0;
    
    if(NULL == sx1278_gpio_ptr)
    {
        result = -ENOMEM;
        goto ERR_EXIT;
    }
    
    gpio_request(sx1278_gpio_ptr->DIO0, "DIO0");
    gpio_request(sx1278_gpio_ptr->DIO1, "DIO1");
    gpio_request(sx1278_gpio_ptr->DIO2, "DIO2");
    gpio_request(sx1278_gpio_ptr->DIO3, "DIO3");
    gpio_request(sx1278_gpio_ptr->DIO4, "DIO4");
    gpio_request(sx1278_gpio_ptr->Reset, "RESET");

    gpio_direction_input(sx1278_gpio_ptr->DIO0);
    gpio_direction_input(sx1278_gpio_ptr->DIO1);
    gpio_direction_input(sx1278_gpio_ptr->DIO2);
    gpio_direction_input(sx1278_gpio_ptr->DIO3);
    gpio_direction_input(sx1278_gpio_ptr->DIO4);
    gpio_direction_output(sx1278_gpio_ptr->Reset, 1);

ERR_EXIT:
    
    return result;
}

int SX1278_IoIrqInit(Sx1278_Gpio_st_ptr sx1278_gpio_ptr, DioIrqHandler **irqHandlers)
{
    int irq = 0;
    int result = 0;

    if((NULL == sx1278_gpio_ptr) || (NULL == *irqHandlers))
    {
        result = -ENOMEM;
        goto ERR_EXIT0;
    }

    irq = gpio_to_irq(sx1278_gpio_ptr->DIO0);
    result = request_irq(irq , irqHandlers[0], IRQF_TRIGGER_RISING, "DI0_IRQ", NULL);
    if(result) 	
    {       
        printk(KERN_ERR "%s %d request_irq ERROR\n", __FUNCTION__, __LINE__);
        ret = -EFAULT;
        goto ERR_EXIT0; 
    }

    irq = gpio_to_irq(sx1278_gpio_ptr->DIO1);
    result = request_irq(irq , irqHandlers[1], IRQF_TRIGGER_RISING, "DI1_IRQ", NULL);
    if(result) 	
    {       
        printk(KERN_ERR "%s %d request_irq ERROR\n", __FUNCTION__, __LINE__);
        ret = -EFAULT;
        goto ERR_EXIT1; 
    }

    irq = gpio_to_irq(sx1278_gpio_ptr->DIO2);
    result = request_irq(irq , irqHandlers[2], IRQF_TRIGGER_RISING, "DI2_IRQ", NULL);
    if(result) 	
    {       
        printk(KERN_ERR "%s %d request_irq ERROR\n", __FUNCTION__, __LINE__);
        ret = -EFAULT;
        goto ERR_EXIT2; 
    }

    irq = gpio_to_irq(sx1278_gpio_ptr->DIO3);
    result = request_irq(irq , irqHandlers[3], IRQF_TRIGGER_RISING, "DI3_IRQ", NULL);
    if(result) 	
    {       
        printk(KERN_ERR "%s %d request_irq ERROR\n", __FUNCTION__, __LINE__);
        ret = -EFAULT;
        goto ERR_EXIT3; 
    }

    irq = gpio_to_irq(sx1278_gpio_ptr->DIO4);
    result = request_irq(irq , irqHandlers[4], IRQF_TRIGGER_RISING, "DI4_IRQ", NULL);
    if(result) 	
    {       
        printk(KERN_ERR "%s %d request_irq ERROR\n", __FUNCTION__, __LINE__);
        ret = -EFAULT;
        goto ERR_EXIT4; 
    }

    return result;

ERR_EXIT4:
    irq = gpio_to_irq(sx1278_gpio_ptr->DIO3);
    free_irq(irq, NULL);    
ERR_EXIT3:
    irq = gpio_to_irq(sx1278_gpio_ptr->DIO2);
    free_irq(irq, NULL);
ERR_EXIT2:
    irq = gpio_to_irq(sx1278_gpio_ptr->DIO1);
    free_irq(irq, NULL);
ERR_EXIT1:
    irq = gpio_to_irq(sx1278_gpio_ptr->DIO0);
    free_irq(irq, NULL);
ERR_EXIT0:
    return result;
}

int SX1278_IoDeInit(Sx1278_Gpio_st_ptr sx1278_gpio_ptr)
{
    int result = 0;

    if(NULL == sx1278_gpio_ptr)
    {
        result = -ENOMEM;
        goto ERR_EXIT;
    }

    gpio_free(sx1278_gpio_ptr->DIO0);
    gpio_free(sx1278_gpio_ptr->DIO1);
    gpio_free(sx1278_gpio_ptr->DIO2);
    gpio_free(sx1278_gpio_ptr->DIO3);
    gpio_free(sx1278_gpio_ptr->DIO4);
    gpio_free(sx1278_gpio_ptr->Reset);

ERR_EXIT:

    return result;
}

int SX1278_Reset(Sx1278_Gpio_st_ptr sx1278_gpio_ptr)
{
    int result = 0;

    if(NULL == sx1278_gpio_ptr)
    {
        result = -ENOMEM;
        goto ERR_EXIT;
    }

    // Set RESET pin to 0
    gpio_direction_output(sx1278_gpio_ptr->Reset, 0);

    // Wait 1 ms
    mdelay(1);

    // Configure RESET as input
    gpio_direction_input(sx1278_gpio_ptr->Reset);

    // Wait 6 ms
    mdelay(6);

ERR_EXIT:

    return result;
}

int SX1278_SetSleep(struct spi_device *spi_ptr)
{
    return SX1278_SetOpMode(spi_ptr, RF_OPMODE_SLEEP);
}

int SX1278_SetStby(struct spi_device *spi_ptr)
{
    return SX1278_SetOpMode(spi_ptr, RF_OPMODE_STANDBY);
}


int SX1278_SetChannel(Sx1278_info_st_ptr sx1278_ptr, unsigned int freq)
{
    int result = 0;

    if(NULL == sx1278_ptr)
    {
        result = -ENOMEM;
        goto ERR_EXIT;
    }
    
    sx1278_ptr.Settings.Channel = freq;
    
    freq = (unsigned int)((double)freq/(double)FREQ_STEP);
    
    result = SX1278_Write_Reg(sx1278_ptr->spi, REG_FRFMSB, (unsigned char)((freq>>16)&0xFF));
    if(result < 0)
    {
        goto ERR_EXIT;
    }
    
    result = SX1278_Write_Reg(sx1278_ptr->spi, REG_FRFMID, (unsigned char)((freq>>8)&0xFF));
    if(result < 0)
    {
        goto ERR_EXIT;
    }
        
    result = SX1278_Write_Reg(sx1278_ptr->spi, REG_FRFLSB, (unsigned char)(freq&0xFF));
    if(result < 0)
    {
        goto ERR_EXIT;
    }
    
ERR_EXIT:

    return result;
}

int SX1278_SetOpMode(struct spi_device *spi_ptr, unsigned char opMode)
{
    int result = 0;
    unsigned char val = 0;
    
    if( opMode == RF_OPMODE_SLEEP )
    {
        //SX1278SetAntSwLowPower( true );
    }
    else
    {
        //SX1278SetAntSwLowPower( false );
        //SX1278SetAntSw( opMode );
    }

    result = SX1278_Read_Reg(spi_ptr, REG_OPMODE, &val);
    if(result < 0)
    {
        goto ERR_EXIT;
    }
    
    result = SX1278_Write_Reg(spi_ptr, REG_OPMODE, ((val&RF_OPMODE_MASK)|opMode));
    if(result < 0)
    {
        goto ERR_EXIT;
    }

ERR_EXIT:

    return result;
}

int SX1278_SetModem(struct spi_device *spi_ptr, RadioModems_en modem)
{
    int result = 0;
    uint8_t val = 0;
    uint8_t cur_modem = 0;
    
    if(NULL == spi_ptr)
    {
        result = -ENOMEM;
        goto ERR_EXIT;
    }

    result = SX1278_Read_Reg(spi_ptr, REG_OPMODE, &val);
    if(result < 0)
    {
        goto ERR_EXIT;
    }

    if((val&RFLR_OPMODE_LONGRANGEMODE_ON) != 0)
    {
        cur_modem = MODEM_LORA;
    }
    else
    {
        cur_modem = MODEM_FSK;
    }

    if(cur_modem == modem)
    {
        goto ERR_EXIT;
    }

    switch(modem)
    {
    default:
    case MODEM_FSK:
        result = SX1278_SetSleep(sx1278_ptr);
        if(result < 0)
        {
            goto ERR_EXIT;
        }

        result = SX1278_Read_Reg(sx1278_ptr->spi, REG_OPMODE, &val);
        if(result < 0)
        {
            goto ERR_EXIT;
        }
        
        result = SX1278_Write_Reg(sx1278_ptr->spi, REG_OPMODE, ((val&RFLR_OPMODE_LONGRANGEMODE_MASK)|RFLR_OPMODE_LONGRANGEMODE_OFF));
        if(result < 0)
        {
            goto ERR_EXIT;
        }    
        
        result = SX1278_Write_Reg(sx1278_ptr->spi, REG_DIOMAPPING1, 0x00);
        if(result < 0)
        {
            goto ERR_EXIT;
        }
        
        result = SX1278_Write_Reg(sx1278_ptr->spi, REG_DIOMAPPING2, 0x30); // DIO5=ModeReady
        if(result < 0)
        {
            goto ERR_EXIT;
        }
        
        break;
    case MODEM_LORA:
        result = SX1278_SetSleep(sx1278_ptr);
        if(result < 0)
        {
            goto ERR_EXIT;
        }

        result = SX1278_Read_Reg(sx1278_ptr->spi, REG_OPMODE, &val);
        if(result < 0)
        {
            goto ERR_EXIT;
        }
        
        result = SX1278_Write_Reg(sx1278_ptr->spi, REG_OPMODE, (val&RFLR_OPMODE_LONGRANGEMODE_MASK)|RFLR_OPMODE_LONGRANGEMODE_ON);
        if(result < 0)
        {
            goto ERR_EXIT;
        }

        result = SX1278_Write_Reg(sx1278_ptr->spi, REG_DIOMAPPING1, 0x00);
        if(result < 0)
        {
            goto ERR_EXIT;
        }
                
        result = SX1278_Write_Reg(sx1278_ptr->spi, REG_DIOMAPPING2, 0x00);
        if(result < 0)
        {
            goto ERR_EXIT;
        }
        break;
    }

ERR_EXIT:

    return result;
}

uint8_t SX1278_GetPaSelect(uint32_t channel)
{
    return RF_PACONFIG_PASELECT_PABOOST;
}


void SX1278_SetRfTxPower(Sx1278_info_st_ptr sx1278_info_ptr, int8_t power)
{
    uint8_t paConfig = 0;
    uint8_t paDac = 0;

    paConfig = SX1278_Read_Reg(sx1278_info_ptr->spi, REG_PACONFIG );
    paDac = SX1278_Read_Reg(sx1278_info_ptr->spi, REG_PADAC );

    paConfig = ( paConfig & RF_PACONFIG_PASELECT_MASK ) | SX1278_GetPaSelect(sx1278_info_ptr->Settings.Channel);
    paConfig = ( paConfig & RF_PACONFIG_MAX_POWER_MASK ) | 0x70;

    if( ( paConfig & RF_PACONFIG_PASELECT_PABOOST ) == RF_PACONFIG_PASELECT_PABOOST )
    {
        if( power > 17 )
        {
            paDac = ( paDac & RF_PADAC_20DBM_MASK ) | RF_PADAC_20DBM_ON;
        }
        else
        {
            paDac = ( paDac & RF_PADAC_20DBM_MASK ) | RF_PADAC_20DBM_OFF;
        }
        if( ( paDac & RF_PADAC_20DBM_ON ) == RF_PADAC_20DBM_ON )
        {
            if( power < 5 )
            {
                power = 5;
            }
            if( power > 20 )
            {
                power = 20;
            }
            paConfig = ( paConfig & RF_PACONFIG_OUTPUTPOWER_MASK ) | ( uint8_t )( ( uint16_t )( power - 5 ) & 0x0F );
        }
        else
        {
            if( power < 2 )
            {
                power = 2;
            }
            if( power > 17 )
            {
                power = 17;
            }
            paConfig = ( paConfig & RF_PACONFIG_OUTPUTPOWER_MASK ) | ( uint8_t )( ( uint16_t )( power - 2 ) & 0x0F );
        }
    }
    else
    {
        if( power < -1 )
        {
            power = -1;
        }
        if( power > 14 )
        {
            power = 14;
        }
        paConfig = ( paConfig & RF_PACONFIG_OUTPUTPOWER_MASK ) | ( uint8_t )( ( uint16_t )( power + 1 ) & 0x0F );
    }
    SX1278_Write_Reg(sx1278_info_ptr->spi, REG_PACONFIG, paConfig);
    SX1278_Write_Reg(sx1278_info_ptr->spi, REG_PADAC, paDac);
}


int SX1278_SetRxConfig(Sx1278_info_st_ptr sx1278_info_ptr, uint32_t bandwidth,
                         uint32_t datarate, uint8_t coderate,
                         uint32_t bandwidthAfc, uint16_t preambleLen,
                         uint16_t symbTimeout, bool fixLen,
                         uint8_t payloadLen,
                         bool crcOn, bool freqHopOn, uint8_t hopPeriod,
                         bool iqInverted, bool rxContinuous )
{
    int result = 0;
    uint8_t val = 0;
    
    SX1278_SetModem(MODEM_LORA);

    if( bandwidth > 2 )
    {
        // Fatal error: When using LoRa modem only bandwidths 125, 250 and 500 kHz are supported
        printk(KERN_ERR "%s %d error\n", __FUNCTION__, __LINE__);
        goto ERR_EXIT;
    }
    
    bandwidth += 7;
    sx1278_info_ptr->Settings.RxLoRa.Bandwidth = bandwidth;
    sx1278_info_ptr->Settings.RxLoRa.Datarate = datarate;
    sx1278_info_ptr->Settings.RxLoRa.Coderate = coderate;
    sx1278_info_ptr->Settings.RxLoRa.PreambleLen = preambleLen;
    sx1278_info_ptr->Settings.RxLoRa.FixLen = fixLen;
    sx1278_info_ptr->Settings.RxLoRa.PayloadLen = payloadLen;
    sx1278_info_ptr->Settings.RxLoRa.CrcOn = crcOn;
    sx1278_info_ptr->Settings.RxLoRa.FreqHopOn = freqHopOn;
    sx1278_info_ptr->Settings.RxLoRa.HopPeriod = hopPeriod;
    sx1278_info_ptr->Settings.RxLoRa.IqInverted = iqInverted;
    sx1278_info_ptr->Settings.RxLoRa.RxContinuous = rxContinuous;

    if( datarate > 12 )
    {
        datarate = 12;
    }
    else if( datarate < 6 )
    {
        datarate = 6;
    }

    if( ( ( bandwidth == 7 ) && ( ( datarate == 11 ) || ( datarate == 12 ) ) ) ||
        ( ( bandwidth == 8 ) && ( datarate == 12 ) ) )
    {
        sx1278_info_ptr->Settings.RxLoRa.LowDatarateOptimize = 0x01;
    }
    else
    {
        sx1278_info_ptr->Settings.RxLoRa.LowDatarateOptimize = 0x00;
    }
    
    SX1278_Read_Reg(sx1278_info_ptr->spi, REG_LR_MODEMCONFIG1, &val);
    SX1278_Write_Reg(sx1278_info_ptr->spi, REG_LR_MODEMCONFIG1,
                 ( val &
                   RFLR_MODEMCONFIG1_BW_MASK &
                   RFLR_MODEMCONFIG1_CODINGRATE_MASK &
                   RFLR_MODEMCONFIG1_IMPLICITHEADER_MASK ) |
                   ( bandwidth << 4 ) | ( coderate << 1 ) |
                   fixLen );

    SX1278_Read_Reg(sx1278_info_ptr->spi, REG_LR_MODEMCONFIG2, &val);
    SX1278_Write_Reg(sx1278_info_ptr->spi, REG_LR_MODEMCONFIG2,
                 ( val &
                   RFLR_MODEMCONFIG2_SF_MASK &
                   RFLR_MODEMCONFIG2_RXPAYLOADCRC_MASK &
                   RFLR_MODEMCONFIG2_SYMBTIMEOUTMSB_MASK ) |
                   ( datarate << 4 ) | ( crcOn << 2 ) |
                   ( ( symbTimeout >> 8 ) & ~RFLR_MODEMCONFIG2_SYMBTIMEOUTMSB_MASK ) );

    SX1278_Read_Reg(sx1278_info_ptr->spi, REG_LR_MODEMCONFIG3, &val);
    SX1278_Write_Reg(sx1278_info_ptr->spi, REG_LR_MODEMCONFIG3,
                 ( val &
                   RFLR_MODEMCONFIG3_LOWDATARATEOPTIMIZE_MASK ) |
                   (sx1278_info_ptr->Settings.RxLoRa.LowDatarateOptimize<<3));

    SX1278_Write_Reg(sx1278_info_ptr->spi, REG_LR_SYMBTIMEOUTLSB, (uint8_t)(symbTimeout&0xFF));

    SX1278_Write_Reg(sx1278_info_ptr->spi, REG_LR_PREAMBLEMSB, (uint8_t)(( preambleLen >> 8)&0xFF));
    SX1278_Write_Reg(sx1278_info_ptr->spi, REG_LR_PREAMBLELSB, (uint8_t)(preambleLen & 0xFF));

    if( fixLen == 1 )
    {
        SX1278_Write_Reg(sx1278_info_ptr->spi, REG_LR_PAYLOADLENGTH, payloadLen );
    }

    if( sx1278_info_ptr->Settings.RxLoRa.FreqHopOn == true )
    {
        SX1278_Read_Reg(sx1278_info_ptr->spi, REG_LR_PLLHOP, &val);
        SX1278_Write_Reg(sx1278_info_ptr->spi, REG_LR_PLLHOP, (val & RFLR_PLLHOP_FASTHOP_MASK ) | RFLR_PLLHOP_FASTHOP_ON );
        SX1278_Write_Reg(sx1278_info_ptr->spi, REG_LR_HOPPERIOD, sx1278_info_ptr->Settings.RxLoRa.HopPeriod );
    }

    if( ( bandwidth == 9 ) && ( sx1278_info_ptr->Settings.Channel > RF_MID_BAND_THRESH ))
    {
        // ERRATA 2.1 - Sensitivity Optimization with a 500 kHz Bandwidth
        SX1278_Write_Reg(sx1278_info_ptr->spi, REG_LR_TEST36, 0x02);
        SX1278_Write_Reg(sx1278_info_ptr->spi, REG_LR_TEST3A, 0x64);
    }
    else if( bandwidth == 9 )
    {
        // ERRATA 2.1 - Sensitivity Optimization with a 500 kHz Bandwidth
        SX1278_Write_Reg( REG_LR_TEST36, 0x02);
        SX1278_Write_Reg( REG_LR_TEST3A, 0x7F);
    }
    else
    {
        // ERRATA 2.1 - Sensitivity Optimization with a 500 kHz Bandwidth
        SX1276Write( REG_LR_TEST36, 0x03 );
    }

    SX1278_Read_Reg(sx1278_info_ptr->spi, REG_LR_DETECTOPTIMIZE, &val);
    if( datarate == 6 )
    {
        
        SX1278_Write_Reg(sx1278_info_ptr->spi, REG_LR_DETECTOPTIMIZE,
                     ( val &
                       RFLR_DETECTIONOPTIMIZE_MASK ) |
                       RFLR_DETECTIONOPTIMIZE_SF6 );
        SX1278_Write_Reg(sx1278_info_ptr->spi, REG_LR_DETECTIONTHRESHOLD,
                     RFLR_DETECTIONTHRESH_SF6 );
    }
    else
    {
        SX1278_Write_Reg(sx1278_info_ptr->spi, REG_LR_DETECTOPTIMIZE,
                     ( val &
                     RFLR_DETECTIONOPTIMIZE_MASK ) |
                     RFLR_DETECTIONOPTIMIZE_SF7_TO_SF12 );
        SX1278_Write_Reg(sx1278_info_ptr->spi, REG_LR_DETECTIONTHRESHOLD,
                     RFLR_DETECTIONTHRESH_SF7_TO_SF12 );
    }

ERR_EXIT:

    return result;
}

int SX1278_SetTxConfig(struct spi_device *spi_ptr, RadioLoRaSettings_st *lora_cfg_ptr)
{
    int result = 0;
    uint8_t val = 0;
    
    SX1278_SetModem(spi_ptr, MODEM_LORA);

    SX1278_SetRfTxPower(spi_ptr, lora_cfg_ptr->power);

    if(lora_cfg_ptr->FreqHopOn == true )
    {
        SX1278_Read_Reg(spi_ptr, REG_LR_PLLHOP, &val);
        SX1278_Write_Reg(spi_ptr, REG_LR_PLLHOP, (val & RFLR_PLLHOP_FASTHOP_MASK ) | RFLR_PLLHOP_FASTHOP_ON );
        SX1278_Write_Reg(spi_ptr, REG_LR_HOPPERIOD, lora_cfg_ptr->HopPeriod );
    }

    SX1278_Read_Reg(sx1278_info_ptr->spi, REG_LR_MODEMCONFIG1, &val);
    SX1278_Write_Reg(sx1278_info_ptr->spi, REG_LR_MODEMCONFIG1,
                 ( val &
                   RFLR_MODEMCONFIG1_BW_MASK &
                   RFLR_MODEMCONFIG1_CODINGRATE_MASK &
                   RFLR_MODEMCONFIG1_IMPLICITHEADER_MASK ) |
                   ( bandwidth << 4 ) | ( coderate << 1 ) |
                   fixLen );

    SX1278_Read_Reg(sx1278_info_ptr->spi, REG_LR_MODEMCONFIG2, &val);
    SX1278_Write_Reg(sx1278_info_ptr->spi, REG_LR_MODEMCONFIG2,
                 ( val &
                   RFLR_MODEMCONFIG2_SF_MASK &
                   RFLR_MODEMCONFIG2_RXPAYLOADCRC_MASK ) |
                   ( datarate << 4 ) | ( crcOn << 2 ) );

    SX1278_Read_Reg(sx1278_info_ptr->spi, REG_LR_MODEMCONFIG3, &val);
    
    SX1278_Write_Reg(sx1278_info_ptr->spi, REG_LR_MODEMCONFIG3,
                 ( val &
                   RFLR_MODEMCONFIG3_LOWDATARATEOPTIMIZE_MASK ) |
                   ( sx1278_info_ptr->Settings.TxLoRa.LowDatarateOptimize << 3 ) );

    SX1278_Write_Reg(sx1278_info_ptr->spi, REG_LR_PREAMBLEMSB, ( preambleLen >> 8 ) & 0x00FF );
    SX1278_Write_Reg(sx1278_info_ptr->spi, REG_LR_PREAMBLELSB, preambleLen & 0xFF );
    SX1278_Read_Reg(sx1278_info_ptr->spi, REG_LR_DETECTOPTIMIZE, &val);
    if( datarate == 6 )
    {
        SX1278_Write_Reg(sx1278_info_ptr->spi, REG_LR_DETECTOPTIMIZE,
                     ( val &
                       RFLR_DETECTIONOPTIMIZE_MASK ) |
                       RFLR_DETECTIONOPTIMIZE_SF6 );
        
        SX1278_Write_Reg(sx1278_info_ptr->spi, REG_LR_DETECTIONTHRESHOLD,
                     RFLR_DETECTIONTHRESH_SF6 );
    }
    else
    {
        SX1278_Write_Reg(sx1278_info_ptr->spi, REG_LR_DETECTOPTIMIZE,
                     ( val &
                     RFLR_DETECTIONOPTIMIZE_MASK ) |
                     RFLR_DETECTIONOPTIMIZE_SF7_TO_SF12 );
        
        SX1278_Write_Reg(sx1278_info_ptr->spi, REG_LR_DETECTIONTHRESHOLD,
                     RFLR_DETECTIONTHRESH_SF7_TO_SF12 );
    }

ERR_EXIT:

    return result;
}

int SX1278_Init(struct spi_device *spi, Sx1278_Gpio_st_ptr sx1278_gpio_ptr)
{
    int result = 0;
    unsigned char i = 0;

    if((NULL == spi) || (NULL == sx1278_gpio_ptr))
    {
        result = -ENOMEM;
        goto ERR_EXIT;
    }
/*
    result = SX1278_IoInit(&sx1278_info.sx1278_gpio);
    if(result < 0)
    {
        goto ERR_EXIT;
    }

    result = SX1278_IoIrqInit(&sx1278_info.sx1278_gpio, DioIrq);
    if(result < 0)
    {
        goto ERR_EXIT;
    } 

    result = SX1278_Reset(&sx1278_info.sx1278_gpio);
    if(result < 0)
    {
        goto ERR_EXIT;
    }
*/

    result = RxChainCalibration(&sx1278_info);
    if(result < 0)
    {
        goto ERR_EXIT;
    }

    result = SX1278_SetOpMode(sx1278_info.spi, RF_OPMODE_SLEEP);
    if(result < 0)
    {
        goto ERR_EXIT;
    }

    result = SX1278_IoIrqInit(sx1278_gpio_ptr, DioIrq);
    if(result < 0)
    {
        goto ERR_EXIT;
    }

    for(i = 0;i < (sizeof( RadioRegsInit )/sizeof( RadioRegisters_t));i++)
    {
        result = SX1278_SetModem(&sx1278_info, RadioRegsInit[i].Modem);
        if(result < 0)
        {
            goto ERR_EXIT;
        }
        
        result = SX1278_Write_Reg(sx1278_info->spi, RadioRegsInit[i].Addr, RadioRegsInit[i].Value);
        if(result < 0)
        {
            goto ERR_EXIT;
        }
    }

    result = SX1278_SetModem(sx1278_info, MODEM_FSK);
    if(result < 0)
    {
        goto ERR_EXIT;
    }

    sx1278_info.Settings.State = RF_IDLE;

ERR_EXIT:

    return result;
}

int SX1278_SendData(uint8_t *data_ptr, uint8_t data_len)
{
    int result = 0;
    uint8_t val = 0;
    uint32_t timeout = 0;

    SX1278_Read_Reg(sx1278_info.spi, REG_LR_INVERTIQ, &val);
    if(sx1278_info.Settings.TxLoRa.IqInverted == true )
    {
        
        SX1278_Write_Reg(sx1278_info.spi, REG_LR_INVERTIQ, ((val & RFLR_INVERTIQ_TX_MASK & RFLR_INVERTIQ_RX_MASK) | RFLR_INVERTIQ_RX_OFF | RFLR_INVERTIQ_TX_ON ));
        SX1278_Write_Reg(sx1278_info.spi, REG_LR_INVERTIQ2, RFLR_INVERTIQ2_ON );
    }
    else
    {
        SX1278_Write_Reg(sx1278_info.spi, REG_LR_INVERTIQ, ((val & RFLR_INVERTIQ_TX_MASK & RFLR_INVERTIQ_RX_MASK) | RFLR_INVERTIQ_RX_OFF | RFLR_INVERTIQ_TX_OFF ));
        SX1278_Write_Reg(sx1278_info.spi, REG_LR_INVERTIQ2, RFLR_INVERTIQ2_OFF );
    }

    sx1278_info.Settings.LoRaPacketHandler.Size = size;

    // Initializes the payload size
    SX1278_Write_Reg(sx1278_info.spi, REG_LR_PAYLOADLENGTH, size);

    // Full buffer used for Tx
    SX1278_Write_Reg(sx1278_info.spi, REG_LR_FIFOTXBASEADDR, 0);
    SX1278_Write_Reg(sx1278_info.spi, REG_LR_FIFOADDRPTR, 0);

    // FIFO operations can not take place in Sleep mode
    SX1278_Read_Reg(sx1278_info.spi, REG_OPMODE, &val);
    if( (val&~RF_OPMODE_MASK) == RF_OPMODE_SLEEP)
    {
        SX1278_SetStby();
        mdelay(1);
    }
    // Write payload buffer
    SX1278_Write_FIFO(sx1278_info.spi, data_ptr, data_len);
    txTimeout = sx1278_info.Settings.TxLoRa.TxTimeout;
    

    if( sx1278_info.Settings.TxLoRa.FreqHopOn == true )
    {
        SX1278_Write_Reg(sx1278_info.spi, REG_LR_IRQFLAGSMASK, RFLR_IRQFLAGS_RXTIMEOUT |
                                          RFLR_IRQFLAGS_RXDONE |
                                          RFLR_IRQFLAGS_PAYLOADCRCERROR |
                                          RFLR_IRQFLAGS_VALIDHEADER |
                                          //RFLR_IRQFLAGS_TXDONE |
                                          RFLR_IRQFLAGS_CADDONE |
                                          //RFLR_IRQFLAGS_FHSSCHANGEDCHANNEL |
                                          RFLR_IRQFLAGS_CADDETECTED );

        // DIO0=TxDone, DIO2=FhssChangeChannel
        SX1278_Read_Reg(sx1278_info.spi, REG_DIOMAPPING1, &val);
        SX1278_Write_Reg(sx1278_info.spi, REG_DIOMAPPING1, ( val & RFLR_DIOMAPPING1_DIO0_MASK & RFLR_DIOMAPPING1_DIO2_MASK ) | RFLR_DIOMAPPING1_DIO0_01 | RFLR_DIOMAPPING1_DIO2_00 );
    }
    else
    {
        SX1278_Write_Reg(sx1278_info.spi, REG_LR_IRQFLAGSMASK, RFLR_IRQFLAGS_RXTIMEOUT |
                                          RFLR_IRQFLAGS_RXDONE |
                                          RFLR_IRQFLAGS_PAYLOADCRCERROR |
                                          RFLR_IRQFLAGS_VALIDHEADER |
                                          //RFLR_IRQFLAGS_TXDONE |
                                          RFLR_IRQFLAGS_CADDONE |
                                          RFLR_IRQFLAGS_FHSSCHANGEDCHANNEL |
                                          RFLR_IRQFLAGS_CADDETECTED );

        // DIO0=TxDone
        SX1278_Read_Reg(sx1278_info.spi, REG_DIOMAPPING1, &val);
        SX1278_Write_Reg(sx1278_info.spi, REG_DIOMAPPING1, ( val & RFLR_DIOMAPPING1_DIO0_MASK ) | RFLR_DIOMAPPING1_DIO0_01 );
    }


    //sx1278_info.Settings.State = RF_TX_RUNNING;
    //schedule_delayed_work(&lora_work, txTimeout);
    //SX1278_SetOpMode( RF_OPMODE_TRANSMITTER );
    
ERR_EXIT:

    return result;    
}

int SX1278_RecvData(uint8_t *data_ptr, uint8_t data_len)
{
    int result = 0;

ERR_EXIT:

    return result;
}

